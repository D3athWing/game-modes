/**
 * Mode Matchmaking
 *
 * Add matchmaking functionnalities to your mode
 */
#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const ModeMatchmakingVersion		"2014-04-16"
#Const ModeMatchmakingScriptName	"ModeMatchmaking.Script.txt"

#Include "TextLib" as MM_TL
#Include "MathLib" as MM_ML
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_MatchmakingAPIUrl		"matchmaking.maniaplanet.com/v2"	as "<hidden>"	///< URL of the matchmaking API | matchmaking.maniaplanet.com/v2
#Setting S_MatchmakingAPILogin		"Login"		as "<hidden>"	///< API username
#Setting S_MatchmakingAPIPassword	"Password"	as "<hidden>"	///< API password
#Setting S_MatchmakingMode			0			as "<hidden>"	///< 0 = Off, 1 = Lobby, 2 = Match
#Setting S_LobbyTimePerRound		60			as "<hidden>"	///< Time limit per round in lobby mode (seconds, 0: no limit)
#Setting S_LobbyRoundPerMap  		30			as "<hidden>"	///< "Nb of rounds per map in lobby mode")
#Setting S_LobbyMatchmakerTime		10			as "<hidden>"	///< Time allocated to the matchmaking (seconds)
#Setting S_LobbyInstagib  			False		as "<hidden>"	///< Laser mode in lobby
#Setting S_LobbyDisplayMasters		True		as "<hidden>"	///< Display the masters list
#Setting S_LogAPIError				False		as "<hidden>"	///< Log the API request errors

// ---------------------------------- //
// Constant
// ---------------------------------- //
#Const C_Matchmaking_Off	0	///< Matchmaking off on this server
#Const C_Matchmaking_Lobby	1	///< Is lobby server
#Const C_Matchmaking_Match	2	///< Is match  server

#Const C_Lobby_Playing		0	///< Playing phase
#Const C_Lobby_Matchmaking	1	///< Matchmaking phase

#Const C_Lobby_MastersNb	20	///< Number of masters displayed
#Const C_Lobby_BotsNb		0	///< Number of bots in the lobby

#Const C_MatchStatus_Waiting	0	///< Waiting for a match to start
#Const C_MatchStatus_Starting	1	///< Match starting
#Const C_MatchStatus_Playing	2	///< Match running
#Const C_MatchStatus_Substitute	3	///< Waiting for a substitute
#Const C_MatchStatus_Ending		4	///< Match ending

#Const C_Match_PingInterval			60000	///< Time interval between each ping
#Const C_Match_PreparationDuration	60000	///< Maximum duration of the match preparation once there's at least one player
#Const C_Match_EndingDuration		15000	///< Maximum duration of the match ending

#Const C_PlayerStatus_Waiting	0	///< Player waiting approval
#Const C_PlayerStatus_Valid		1	///< Player approved
#Const C_PlayerStatus_Invalid	2	///< Player rejected

#Const C_AllyStatus_Validated		0	///< Ally validated
#Const C_AllyStatus_Sent			1	///< Ally request sent to this player
#Const C_AllyStatus_Disconnected	2	///< Ally disconnected

#Const C_Request_GetPlayers		0	///< /player?login=somelogin
#Const C_Request_PostPlayers	1	///< /players
#Const C_Request_GetMatches		2	///< /match?serverlogin=somelogin
#Const C_Request_PostStatus		3	///< /status
#Const C_Request_PostResults	4	///< /result

#Const C_Master_Timestamp	0	///< Timestamp of the master match
#Const C_Master_Name		1	///< Name of the master
#Const C_Master_Country		2	///< Country of the master
#Const C_Master_Echelon		3	///< Echelon of the master

#Const C_Matchmaking_Debug	False	///< Enable debug info

// ---------------------------------- //
// Globales
// ---------------------------------- //
declare Integer		G_Matchmaking_Mode;			///< Current matchmaking mode, see S_MatchmakingMode
declare Integer[]	G_Matchmaking_Format;		///< Format of the match making [NbPlayersTeam1, NbPlayersTeam2, ..., NbPlayersTeamN]
declare Integer		G_Matchmaking_MaxPlayers;	///< Maximum number of players in the biggest clan
declare Integer[Ident] G_Matchmaking_RequestsIds;	///< Ident and type of the requests sent by the match making
declare Integer		G_Lobby_BestCombo;			///< Current best combo in lobby
declare Ident		G_Lobby_WinnerId;			///< Current round winner
declare Integer		G_Lobby_StartTime;			///< Lobby start time
declare Integer		G_Lobby_EndTime;			///< Lobby end time
declare Integer		G_Lobby_Phase;				///< Current lobby phase : playing/matchmaking
declare Text[]		G_Lobby_MastersLogins;		///< List of masters logins
declare Integer		G_Match_Status;				///< Current match status
declare Integer[Text] G_Match_Players;			///< Logins and clans of the allowed players in the match
declare Integer		G_Match_Id;					///< Id of the match
declare Text		G_Match_LobbyLogin;			///< Login of the lobby server where to send back the players
declare Integer		G_Match_NextPing;			///< Time of the next ping of the match server to the API
declare Real[Text]	G_Match_MissingPlayers;		///< List of missing players login

// ---------------------------------- //
// Extend
// ---------------------------------- //
***LogVersion***
***
MB_LogVersion(ModeMatchmakingScriptName, ModeMatchmakingVersion);
MB_LogVersion(Layers::GetScriptName(), Layers::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
***

// ---------------------------------- //
// Matchmaking
// ---------------------------------- //
***StartServer***
***
Layers::Create("StartingMatch", Private_MM_GetMLStartingMatch());
Layers::SetType("StartingMatch", CUILayer::EUILayerType::CutScene);

Layers::Create("SendToServer", Private_Lobby_GetMLSendToServer());
Layers::Attach("SendToServer");

// @Debug
foreach (Player in AllPlayers) {
	declare Matchmaking_PlayerStatus for Player = C_PlayerStatus_Waiting;
	Matchmaking_PlayerStatus = C_PlayerStatus_Waiting;
}
***

***PlayLoop***
***
Private_MM_PlayLoop();
***

***EndServer***
***
Layers::Destroy("StartingMatch");
Layers::Destroy("SendToServer");
***

***Matchmaking***
***
MM_SetMode(S_MatchmakingMode);

switch (G_Matchmaking_Mode) {
	case C_Matchmaking_Lobby: {
		Admin_SetLobbyInfo(True, 0, 255, 0.);
		---Lobby---
	}
	default: {
		Admin_SetLobbyInfo(False, 0, 0, 0.);
	}
}
***

// ---------------------------------- //
// Lobby
// ---------------------------------- //
***Lobby***
***
+++LobbyInitServer+++
+++LobbyStartServer+++
XmlRpc::Load();
Clublink::Load(MB_UsePlayerClublinks);

// ---------------------------------- //
// Match sequence start
// ---------------------------------- //
while (
	!ServerShutdownRequested
	&& !MB_StopServer
) {
	// Match initialization
	MB_CurrentSection = "LobbyStartMatch";
	MB_SectionMatchNb	+= 1;
	MB_SectionMapNb		= 0;
	MB_StopMatch		= False;
	MB_XmlRpcCheck();
	MB_NeutralEmblemUpdate();
	
	if (MB_UseLogging) MB_Log("LobbyStartMatch");
	
	+++LobbyInitMatch+++
	XmlRpc::BeginMatch(MB_SectionMatchNb);
	+++LobbyStartMatch+++
	Clublink::Update();

// ---------------------------------- //
// Map sequence start
// ---------------------------------- //
	while (
		!ServerShutdownRequested
		&& !MB_StopServer
		&& !MB_StopMatch
	) {
		// Map initialization
		MB_CurrentSection = "LobbyStartMap";
		MB_SectionMapNb += 1;
		MB_SectionRoundNb = 0;
		MB_StopMap = False;
		MatchEndRequested = False;
		MB_XmlRpcCheck();
		MB_NeutralEmblemUpdate();
		
		+++LobbyBeforeLoadMap+++
		
		XmlRpc::LoadingMap(MB_SectionMapNb);
		Mode::LoadMap();
		
		if (MB_UseLogging) MB_Log("LobbyStartMap");

		+++LobbyInitMap+++
		
		XmlRpc::BeginMap(MB_SectionMapNb);
		Mode::Synchro_DoBarrier();
		
		// Play mediatracker intro
		if (MB_UseIntro) {
			---MapIntro---
		}
		
		+++LobbyStartMap+++
		Clublink::Update();
// ---------------------------------- //
// Round sequence start
// ---------------------------------- //				
		while (!ServerShutdownRequested
			&& !MB_StopServer
			&& !MatchEndRequested
			&& !MB_StopMatch
			&& !MB_StopMap
			&& !MB_StopSubmatch
		) {
			// Round initialization
			MB_CurrentSection = "LobbyStartRound";
			MB_XmlRpcCheck();
			MB_NeutralEmblemUpdate();
			+++LobbyInitRound+++
			MB_StopRound = False;
			if (MB_UseSectionRound) {
				MB_SectionRoundNb += 1;
				if (MB_UseLogging) MB_Log("LobbyStartRound");
				
				XmlRpc::BeginRound(MB_SectionRoundNb);
				+++LobbyStartRound+++
				Clublink::Update();
			}
			MB_SectionTurnNb = 0;
			
			MB_CurrentSection = "LobbyPlayLoop";
// ---------------------------------- //
// Play loop
// ---------------------------------- //					
			while (!ServerShutdownRequested
				&& !MB_StopServer
				&& !MatchEndRequested
				&& !MB_StopMatch
				&& !MB_StopMap
				&& !MB_StopSubmatch
				&& !MB_StopRound
				&& !MB_StopTurn
			) {
				MM_Yield();
				+++LobbyPlayLoop+++
			}
// ---------------------------------- //
// Round end
// ---------------------------------- //
			MB_CurrentSection = "LobbyEndRound";
			MB_XmlRpcCheck();
			MB_NeutralEmblemUpdate();
			if (MB_UseSectionRound) {
				if (MB_UseLogging) MB_Log("LobbyEndRound");
				
				XmlRpc::EndRound(MB_SectionRoundNb);
				+++LobbyEndRound+++
				XmlRpc::SendScores();
			}
		}
// ---------------------------------- //
// Map end
// ---------------------------------- //
		MB_CurrentSection = "LobbyEndMap";
		MB_XmlRpcCheck();
		MB_NeutralEmblemUpdate();
		if (MB_UseLogging) MB_Log("LobbyEndMap");
		
		XmlRpc::EndMap(MB_SectionMapNb);
		
		// Play mediatracker outro
		if (MB_UseOutro) {
			---MapOutro---
		}
		
		+++LobbyEndMap+++
		XmlRpc::SendScores();
		Mode::UnloadMap();
		
		+++LobbyAfterUnloadMap+++
	}
// ---------------------------------- //
// Match end
// ---------------------------------- //
	MB_CurrentSection = "LobbyEndMatch";
	MB_XmlRpcCheck();
	MB_NeutralEmblemUpdate();
	if (MB_UseLogging) MB_Log("LobbyEndMatch");
	
	XmlRpc::EndMatch(MB_SectionMatchNb);
	+++LobbyEndMatch+++
	XmlRpc::SendScores();
}

XmlRpc::Unload();
Clublink::Unload();
+++LobbyEndServer+++
***

***LobbyStartServer***
***
// ---------------------------------- //
// Check settings
if (S_MatchmakingAPIUrl == "") MB_Log("[ERROR] You must set a matchmaking API URL in your settings.");
assert(S_MatchmakingAPIUrl != "", "You must set a matchmaking API URL in your settings.");

if (S_MatchmakingAPILogin == "") MB_Log("[ERROR] You must set a matchmaking API login in your settings.");
assert(S_MatchmakingAPILogin != "", "You must set a matchmaking API login in your settings.");

if (S_MatchmakingAPIPassword == "") MB_Log("[ERROR] You must set a matchmaking API password in your settings.");
assert(S_MatchmakingAPIPassword != "", "You must set a matchmaking API password in your settings.");

// ---------------------------------- //
// Config lobby
UseAllies = True;
UseClans = False;
MB_UseIntro = False;
MB_UseOutro = False;
MB_UseSectionRound = True;
declare PrevLobbyDisplayMasters = True;

// ---------------------------------- //
// Clean the masters list
G_Lobby_MastersLogins.clear();
declare netwrite Integer Net_Lobby_MastersUpdate for Teams[0];
declare netwrite Text[Integer][] Net_Lobby_Masters for Teams[0];
Net_Lobby_Masters.clear();
Net_Lobby_MastersUpdate = -1;

// ---------------------------------- //
// Initialize UI
UIManager.UIAll.AlliesLabelsVisibility = CUIConfig::ELabelsVisibility::WhenVisible;
UIManager.UIAll.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::WhenVisible;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;
UIManager.UIAll.OverlayHideCountdown = True;
UIManager.UIAll.AltMenuNoCustomScores = True;
UIManager.UIAll.AltMenuNoDefaultScores = True;

declare netwrite Integer Net_Lobby_PlayersNb for Teams[0];
declare netwrite Integer Net_Lobby_WaitingTime for Teams[0];
Net_Lobby_PlayersNb = 0;
Net_Lobby_WaitingTime = -1;

// ---------------------------------- //
// Load rules manialink
declare MLRules = Private_Lobby_GetMLRules();
declare DisplayRules = True;
if (MLRules == "") DisplayRules = False;

Layers::Create("RulesReminder", Private_Lobby_GetMLRulesReminder());
Layers::Create("GaugeTimer", Private_Lobby_GetMLGaugeTimer());
Layers::Create("WaitingScreen", Private_Lobby_GetMLWaitingScreen(DisplayRules));
Layers::Create("PlayersList", Private_Lobby_GetMLPlayersList());
Layers::Create("MastersList", Private_Lobby_GetMLMastersList());
Layers::Create("Header", Private_Lobby_GetMLHeader());
Layers::Create("SendToServer", Private_Lobby_GetMLSendToServer());
Layers::Create("Rules", Private_Lobby_GetMLRules());
Layers::Create("Versus", Private_Lobby_GetMLVersus());
Layers::Create("Substitute", Private_Lobby_GetMLSubstitute());
Layers::Attach("RulesReminder");
Layers::Attach("GaugeTimer");
Layers::Attach("WaitingScreen");
Layers::Attach("PlayersList");
Layers::Attach("MastersList");
Layers::Attach("Header");
Layers::Attach("SendToServer");
Layers::Attach("Rules");
Layers::Attach("Versus");
Layers::Attach("Substitute");
Layers::SetType("RulesReminder", CUILayer::EUILayerType::CutScene);
Layers::SetType("GaugeTimer", CUILayer::EUILayerType::CutScene);
Layers::SetType("WaitingScreen", CUILayer::EUILayerType::CutScene);
Layers::SetType("PlayersList", CUILayer::EUILayerType::CutScene);
Layers::SetType("MastersList", CUILayer::EUILayerType::CutScene);
Layers::SetType("Header", CUILayer::EUILayerType::CutScene);
Layers::SetType("Rules", CUILayer::EUILayerType::CutScene);
Layers::SetType("Versus", CUILayer::EUILayerType::CutScene);
Layers::SetType("Substitute", CUILayer::EUILayerType::CutScene);

foreach (Player in AllPlayers) {
	declare Lobby_IsNew for Player = True;
	Lobby_IsNew = True;
}
/*foreach (User in Users) {
	declare Lobby_LastUpdate for User = -1;
	declare Lobby_Disconnected for User = True;
	Lobby_LastUpdate = -1;
	Lobby_Disconnected = True;
}*/
***

***LobbyStartMap***
***
// ---------------------------------- //
// Initialize UI
Message::CleanBigMessages();
//UIManager.UIAll.UISequence = CUIConfig::EUISequence::UIInteraction;

// ---------------------------------- //
// Initialize bots
Users_SetNbFakeUsers(C_Lobby_BotsNb, 0);

// ---------------------------------- //
// Initialize rules
declare ModeName = _("Lobby");
SpawnScreen::ResetRulesSection();
SpawnScreen::AddSubsection(
	_("Objectives"),
	MM_TL::Compose("$<%1%2$>\n\n%3\n$<%11. $>%4\n$<%12. $>%5", "$"^SpawnScreen::GetModeColor(), _("You will soon be redirected to a match server."), _("While waiting, try to become the King Of The Lobby!"), _("Perform as many hits as possible: the points you earn for each one will increase."), _("Your combo falls back to 1 when you are eliminated.")),
	0.
);
SpawnScreen::AddSubsection(_("Type"), _("Free for all"), 60.);
SpawnScreen::CreatePrettyRules(ModeName, False);

// ---------------------------------- //
// Initialize timers
StartTime = Now + 3000;
EndTime = -1;
***

***LobbyStartRound***
***
G_Lobby_BestCombo = 0;
G_Lobby_WinnerId = NullId;
G_Lobby_Phase = C_Lobby_Playing;

// ---------------------------------- //
// Initialize timers
G_Lobby_StartTime = Now;
if (S_LobbyTimePerRound > 0) {
	G_Lobby_EndTime = G_Lobby_StartTime + (S_LobbyTimePerRound * 1000);
} else {
	G_Lobby_EndTime = -1;
}

// ---------------------------------- //
// Initialize scores
ClearScores();
foreach (Score in Scores) {
	Score.Points = 0;
	Score.RoundPoints = 0;
}
***

***LobbyPlayLoop***
***
Private_Lobby_UpdateUI();
Private_Lobby_SpawnPlayers();
Private_Lobby_UpdateTimers();

if (PrevLobbyDisplayMasters != S_LobbyDisplayMasters) {
	PrevLobbyDisplayMasters = S_LobbyDisplayMasters;
	Layers::SetVisibility("MastersList", S_LobbyDisplayMasters);
}

// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	if (Event.Type == CSmModeEvent::EType::OnHit) {
		if (Event.Shooter != Null && Event.Victim != Null && Event.Shooter != Event.Victim) {
			declare PointsEarned = Private_Lobby_NotifyHit(Event.Shooter);
			Event.ShooterPoints = PointsEarned;
			PassOn(Event);
		} else {
			Discard(Event);
		}
	} else if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
		if (Event.Victim != Null) {
			Private_Lobby_ResetPlayer(Event.Victim);
		}
		PassOn(Event);
	} else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {
		if (Event.Player != Null) {
			Private_Lobby_ResetPlayer(Event.Player);
		}
		PassOn(Event);
	} else {
		PassOn(Event);
	}
}

// ---------------------------------- //
// Change phase
switch (G_Lobby_Phase) {
	// ---------------------------------- //
	// Start Matchmaking
	case C_Lobby_Playing: {
		if (G_Lobby_EndTime > 0 && Now > G_Lobby_EndTime) {
			G_Lobby_Phase = C_Lobby_Matchmaking;
			Message::CleanAllMessages();
			Private_Lobby_ReinitPlayers();
			
			// ---------------------------------- //
			// Find the winner
			declare BestScore = G_Lobby_BestCombo;
			if (G_Lobby_WinnerId == NullId || !Users.existskey(G_Lobby_WinnerId)) {
				// Recompute the winner
				G_Lobby_WinnerId = NullId;
				BestScore = 0;
				foreach (Score in Scores) {
					if (Score.Points > BestScore) {
						BestScore = Score.Points;
						G_Lobby_WinnerId = Score.User.Id;
					}
				}
			}
			
			// ---------------------------------- //
			// Announce the winner
			if (G_Lobby_WinnerId != NullId && Users.existskey(G_Lobby_WinnerId)) {
				Message::SendBigMessage(
					MM_TL::Compose(_("$<%1$> is King of the Lobby!"), Users[G_Lobby_WinnerId].Name),
					5000,
					3
				);
			} else {
				Message::SendBigMessage(
					_("|Match|Draw"),
					5000,
					3
				);
			}
			Mode::PlaySound(CUIConfig::EUISound::EndRound, 0);
			
			// ---------------------------------- //
			// Start matchmaking
			Message::SendStatusMessage(
				_("Matchmaking in progress..."),
				S_LobbyMatchmakerTime * 1000,
				1
			);
			
			Private_Lobby_SetTimersAutoDown(S_LobbyMatchmakerTime * 1000);
			G_Lobby_EndTime = Now + (S_LobbyMatchmakerTime * 1000);
			
			Private_MM_ComputeAllies();
			MM_MatchMakerStart();
		}
	}
	// ---------------------------------- //
	// Start playing
	case C_Lobby_Matchmaking: {
		MM_MatchMakerRun();
			
		if (G_Lobby_EndTime > 0 && Now > G_Lobby_EndTime) {
			MM_MatchMakerStop();
			
			if (MB_SectionRoundNb >= S_LobbyRoundPerMap) {
				MB_StopMap();
			} else {
				MB_StopRound();
			}
		}
	}
}
***

***LobbyEndMap***
***
SM::UnspawnAllPlayers();
MM_Sleep(5000);
Message::CleanAllMessages();
MM_Sleep(10000);
***

***LobbyEndServer***
***
UseAllies = False;
UIManager.UIAll.OverlayHideCountdown = False;
UIManager.UIAll.AltMenuNoCustomScores = False;

Layers::Destroy("RulesReminder");
Layers::Destroy("GaugeTimer");
Layers::Destroy("WaitingScreen");
Layers::Destroy("PlayersList");
Layers::Destroy("MastersList");
Layers::Destroy("Header");
Layers::Destroy("SendToServer");
Layers::Destroy("Rules");
Layers::Destroy("Versus");
Layers::Destroy("Substitute");
***

***MatchMakerStart***
***
declare Ident Lobby_MatchMakerRequestId for This;
// Destroy any previous request
if (Lobby_MatchMakerRequestId != NullId) {
	if (Http.Requests.existskey(Lobby_MatchMakerRequestId)) {
		Http.Destroy(Http.Requests[Lobby_MatchMakerRequestId]);
	}
}

// Send the request to the API
if (Http.SlotsAvailable > 0) {
	declare PlayersList = "";
	declare FirstPlayer = True;
	foreach (Player in Players) {
		declare Integer Lobby_ReadySince for Player;
		declare Integer[Ident] Lobby_Allies for Player;
		declare Lobby_AlliesAreReady for Player = False;
		
		// If one of the player ally is not ready don't send him in a match
		if (Lobby_Allies.count > 0 && !Lobby_AlliesAreReady) continue;
		
		if (FirstPlayer) FirstPlayer = False;
		else PlayersList ^= ",";
		
		declare AlliesList = "";
		declare FirstAlly = True;
		foreach (AllyId => AllyStatus in Lobby_Allies) {
			if (!AllPlayers.existskey(AllyId)) continue;
			
			if (FirstAlly) FirstAlly = False;
			else AlliesList ^= ",";
			AlliesList ^= "\""^AllPlayers[AllyId].Login^"\"";
		}
		
		PlayersList ^= """
{
	"login": "{{{MM_TL::MLEncode(Player.Login)}}}",
	"ladderpoints": {{{MM_ML::NearestInteger(Player.User.LadderPoints)}}},
	"readytime": {{{Now - Lobby_ReadySince}}},
	"allies": [{{{AlliesList}}}]
}""";
	}
	
	declare PostData = """
{
	"lobby": "{{{MM_TL::MLEncode(ServerLogin)}}}",
	"gamemode": "{{{MM_TL::MLEncode(ServerModeName)}}}",
	"titleid": "{{{MM_TL::MLEncode(LoadedTitle.TitleId)}}}",
	"format": {{{G_Matchmaking_Format}}},
	"players": [
		{{{PlayersList}}}
	]
}""";
	declare Request <=> Http.CreatePost(Private_MM_BuildAPIUrl("/players"), PostData);
	if (Request != Null) Lobby_MatchMakerRequestId = Request.Id;
	
	if (C_Matchmaking_Debug) MB_Log("[API] Request: POST /players\n"^PostData);
}
***

***MatchMakerRun***
***
declare Ident Lobby_MatchMakerRequestId for This;
declare Ident ToRemove;
foreach (Request in Http.Requests) {
	if (Request.Id != Lobby_MatchMakerRequestId) continue;
	
	if (Request.IsCompleted) {
		// Success
		if (Request.StatusCode == 200) {
			MM_GetMatches(Request.Result);
		}
		// Fail
		else {
			if (S_LogAPIError) {
				if (Request.StatusCode == 401) {
					MB_Log("[ERROR] Matchmaking HTTP API Error 401. Maybe the login or password in the setting is wrong.");
				} else if (Request.StatusCode == 404) {
					MB_Log("[ERROR] Matchmaking HTTP API Error 404. Maybe the URL in the setting is wrong.");
				} else {
					MB_Log("[ERROR] Matchmaking HTTP Error "^Request.StatusCode^".");
				}
			}
		}
		ToRemove = Request.Id;
	}
}
if (ToRemove != NullId) {
	Http.Destroy(Http.Requests[ToRemove]);
	Lobby_MatchMakerRequestId = NullId;
}
***

***MatchMakerStop***
***
// Destroy any previous request
declare Ident Lobby_MatchMakerRequestId for This;
if (Lobby_MatchMakerRequestId != NullId) {
	if (Http.Requests.existskey(Lobby_MatchMakerRequestId)) {
		if (S_LogAPIError) MB_Log("[ERROR] Matchmaking HTTP Error XXX. API timeout.");
		Http.Destroy(Http.Requests[Lobby_MatchMakerRequestId]);
	}
}

foreach (Player in AllPlayers) {
	Private_MM_HideVersusML(Player);
}

// Send players to their match
MM_SendToMatches();
***

***InitMap***
***
// Matchmaking already have an intro, skip the default one
if (S_MatchmakingMode == 2) MB_UseIntro = False;
else MB_UseIntro = True;
***

// ---------------------------------- //
// Functions
// ---------------------------------- //
// ---------------------------------- //
/** Build the url to call the API
 *
 *	@param	_Path		The endpoint to call
 */
Text Private_MM_BuildAPIUrl(Text _Path) {
	return "http://"^S_MatchmakingAPILogin^":"^S_MatchmakingAPIPassword^"@"^S_MatchmakingAPIUrl^_Path;
	//return S_MatchmakingAPIUrl^_Path;
}

// ---------------------------------- //
/** Show the versus manialink to a player
 *
 *	@param	_Player		The player to update
 */
Void Private_MM_ShowVersusML(CSmPlayer _Player) {
	if (_Player == Null) return;
	declare UI <=> UIManager.GetUI(_Player);
	if (UI == Null) return;
	
	UnspawnPlayer(_Player);
	
	declare Lobby_IsSubstitute for _Player.User = False;
	if (Lobby_IsSubstitute) {
		declare netwrite Net_Lobby_ShowSubstituteML for UI = False;
		Net_Lobby_ShowSubstituteML = True;
	} else {
		declare netwrite Net_Lobby_ShowVersusML for UI = False;
		Net_Lobby_ShowVersusML = True;
	}
	
	declare Lobby_OnVersusScreen for _Player = False;
	Lobby_OnVersusScreen = True;
}

// ---------------------------------- //
/** Hide the versus manialink from a player
 *
 *	@param	_Player		The player to update
 */
Void Private_MM_HideVersusML(CSmPlayer _Player) {
	if (_Player == Null) return;
	declare UI <=> UIManager.GetUI(_Player);
	if (UI == Null) return;
	
	declare netwrite Net_Lobby_ShowSubstituteML for UI = False;
	declare netwrite Net_Lobby_ShowVersusML for UI = False;
	Net_Lobby_ShowSubstituteML = False;
	Net_Lobby_ShowVersusML = False;
	
	declare Lobby_OnVersusScreen for _Player = False;
	Lobby_OnVersusScreen = False;
}

// ---------------------------------- //
/** Set the new matchmaking mode on this server
 *
 *	@param	_NewMode		The new mode
 */
Void MM_SetMode(Integer _NewMode) {
	switch (_NewMode) {
		case C_Matchmaking_Lobby	: G_Matchmaking_Mode = C_Matchmaking_Lobby;
		case C_Matchmaking_Match	: G_Matchmaking_Mode = C_Matchmaking_Match;
		default						: G_Matchmaking_Mode = C_Matchmaking_Off;
	}
}

// ---------------------------------- //
/** Create a link to join another server in the same title
 *
 *	@param	_ServerLogin	The login of the server to join
 */
Text MM_GetServerJoinLink(Text _ServerLogin) {
	return "#qjoin="^_ServerLogin^"@"^LoadedTitle.TitleId;
}

// ---------------------------------- //
/** Send a player to another server
 *
 *	@param	_Player			The player to send
 *	@param	_ServerLogin	The server login where to send the player
 */
Void MM_SendToServer(CPlayer _Player, Text _ServerLogin) {
	if (_Player == Null || _ServerLogin == "") return;
	declare UI <=> UIManager.GetUI(_Player);
	if (UI == Null) return;
	
	declare netwrite Integer Net_Lobby_JoinLinkUpdate for UI;
	declare netwrite Text Net_Lobby_JoinLink for UI;
	Net_Lobby_JoinLinkUpdate = Now;
	Net_Lobby_JoinLink = MM_GetServerJoinLink(_ServerLogin);
}

// ---------------------------------- //
/** Parse the matches XML and send player to their match server
 *
 *	@param	_MatchesXML			The XML containing the matches
 */
Void MM_GetMatches(Text _MatchesXML) {
	if (C_Matchmaking_Debug) MB_Log("[API] Response: POST /players\n"^_MatchesXML);
	// Get matches info from XML
	declare MatchesPlayers = Integer[CSmPlayer][Text];
	declare MatchesLogins = Integer[Text][Text];
	declare XmlDoc <=> Xml.Create(_MatchesXML);
	if (XmlDoc != Null && XmlDoc.Root != Null) {
		declare NodeStatus <=> XmlDoc.Root.GetFirstChild("status");
		if (NodeStatus != Null) {
			declare netwrite Integer Net_Lobby_PlayersNb for Teams[0];
			declare netwrite Integer Net_Lobby_WaitingTime for Teams[0];
			declare netwrite Integer Net_Lobby_ServersAvailable for Teams[0];
			Net_Lobby_PlayersNb = NodeStatus.GetAttributeInteger("playersnb", 0);
			Net_Lobby_WaitingTime = NodeStatus.GetAttributeInteger("waitingtime", -1);
			Net_Lobby_ServersAvailable = NodeStatus.GetAttributeInteger("availableservers", 0);
			
			Admin_SetLobbyInfo(True, Net_Lobby_PlayersNb, 255, 0.);
			
			// No match server available
			if (Net_Lobby_ServersAvailable <= 0) {
				Message::SendStatusMessage(
					_("Matchmaking cancelled : no server available"),
					G_Lobby_EndTime - Now,
					1
				);
			}
			
			declare NodeMatches <=> XmlDoc.Root.GetFirstChild("matches");
			if (NodeMatches != Null) {
				foreach (NodeMatch in NodeMatches.Children) {
					declare MatchId = NodeMatch.GetAttributeText("id", "");
					if (MatchId == "") continue;
					MatchesPlayers[MatchId] = Integer[CSmPlayer];
					MatchesLogins[MatchId] = Integer[Text];
					// Match
					if (NodeMatch.Name == "match") {
						declare MatchServerLogin = "";
						foreach (Node in NodeMatch.Children) {
							// Server
							if (Node.Name == "server") {
								MatchServerLogin = Node.GetAttributeText("match", "");
							} 
							// Players
							else if (Node.Name == "players" && MatchServerLogin != "") {
								// Player
								foreach (NodePlayer in Node.Children) {
									declare Login = NodePlayer.GetAttributeText("login", "");
									declare Clan = NodePlayer.GetAttributeInteger("clan", -1);
									if (G_Matchmaking_Format.count > 1) Clan += 1;
									if (Login != "" && Clan >= 0) {
										declare Player <=> SM::GetPlayer(Login);
										if (Player != Null) {
											declare Lobby_MatchId for Player.User = "";
											declare Lobby_MatchServer for Player.User = "";
											declare Lobby_IsSubstitute for Player.User = False;
											Lobby_MatchId = MatchId;
											Lobby_MatchServer = MatchServerLogin;
											Lobby_IsSubstitute = False;
											MatchesPlayers[MatchId][Player] = Clan;
											MatchesLogins[MatchId][Player.Login] = Clan;
										}
									}
								}
							}
						}
					}
				}
			}
			
			declare NodeSubstitutes <=> XmlDoc.Root.GetFirstChild("substitutes");
			if (NodeSubstitutes != Null) {
				foreach (NodePlayer in NodeSubstitutes.Children) {
					declare Login = NodePlayer.GetAttributeText("login", "");
					declare MatchServerLogin = NodePlayer.GetAttributeText("server", "");
					if (Login != "" && MatchServerLogin != "") {
						declare Player <=> SM::GetPlayer(Login);
						declare Lobby_MatchId for Player.User = "";
						declare Lobby_MatchServer for Player.User = "";
						declare Lobby_IsSubstitute for Player.User = False;
						Lobby_MatchId = "";
						Lobby_MatchServer = MatchServerLogin;
						Lobby_IsSubstitute = True;
						
						Private_MM_ShowVersusML(Player);
					}
				}
			}
		}
	}
	
	// Send match to player UI
	foreach (MatchId => MatchPlayers in MatchesPlayers) {
		foreach (Player => Clan in MatchPlayers) {
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;
			
			declare netwrite Integer Net_Lobby_VersusPlayersUpdate for UI;
			declare netwrite Integer[Text] Net_Lobby_VersusPlayers for UI;
			Net_Lobby_VersusPlayers = MatchesLogins[MatchId];
			Net_Lobby_VersusPlayersUpdate = Now;
			
			Private_MM_ShowVersusML(Player);
		}
	}
}

// ---------------------------------- //
/// Send all players in their matches
Void MM_SendToMatches() {
	foreach (Player in AllPlayers) {
		declare Lobby_MatchServer for Player.User = "";
		if (Lobby_MatchServer != "") {
			MM_SendToServer(Player, Lobby_MatchServer);
		}
	}
	foreach (User in Users) {
		declare Lobby_MatchId for User = "";
		declare Lobby_MatchServer for User = "";
		declare Lobby_IsSubstitute for User = False;
		Lobby_MatchId = "";
		Lobby_MatchServer = "";
		Lobby_IsSubstitute = False;
	}
}

// ---------------------------------- //
/** Let a player cancel a match
 *
 *	@param	_User		The user who want to cancel his match
 */
Void MM_CancelMatch(CUser _User) {
	if (_User == Null) return;
	
	declare Lobby_MatchId as CancelMatchId for _User = "";
	if (CancelMatchId != "") {
		foreach (User in Users) {
			declare Lobby_MatchId for User = "";
			declare Lobby_MatchServer for User = "";
			declare Lobby_IsSubstitute for User = False;
			
			if (CancelMatchId != Lobby_MatchId) continue;
			
			Lobby_MatchId = "";
			Lobby_MatchServer = "";
			Lobby_IsSubstitute = False;
			
			declare Player <=> SM::GetPlayer(User.Login);
			Private_MM_HideVersusML(Player);
		}
	} else {
		declare Lobby_MatchServer for _User = "";
		declare Lobby_IsSubstitute for _User = False;
		CancelMatchId = "";
		Lobby_MatchServer = "";
		Lobby_IsSubstitute = False;
		declare Player <=> SM::GetPlayer(_User.Login);
		Private_MM_HideVersusML(Player);
	}
}

// ---------------------------------- //
/// Start the MatchMaker
Void MM_MatchMakerStart() {
	---MatchMakerStart---
}

// ---------------------------------- //
/// Run the MatchMaker
Void MM_MatchMakerRun() {
	---MatchMakerRun---
}

// ---------------------------------- //
/// Start the MatchMaker
Void MM_MatchMakerStop() {
	---MatchMakerStop---
}

// ---------------------------------- //
/** Check if a player is allowed to play by the matchmaking
 *
 *	@param	_Player		The player to check
 *
 *	@return			True if the player is allowed to play, false otherwise
 */
Boolean MM_PlayerIsValid(CSmPlayer _Player) {
	if (_Player == Null) return False;
	
	declare Matchmaking_PlayerStatus for _Player = C_PlayerStatus_Waiting;
	return (Matchmaking_PlayerStatus == C_PlayerStatus_Valid);
}

// ---------------------------------- //
/// Send the server status to the API
Void Private_MM_PostMatchStatus() {
	if (Http.SlotsAvailable > 0) {
		declare MissingPlayers = "";
		if (G_Match_MissingPlayers.count > 0) {
			declare NotFirst = False;
			foreach (Login => LadderPoints in G_Match_MissingPlayers) {
				if (NotFirst) MissingPlayers ^= ",";
				else NotFirst = True;
				
				MissingPlayers ^= """{"login":"{{{Login}}}","ladderpoints":{{{MM_ML::NearestInteger(LadderPoints)}}}}""";
			}
		}
		declare PostData = """
{
	"serverlogin": "{{{ServerLogin}}}",
	"status": {{{G_Match_Status}}},
	"matchid": {{{G_Match_Id}}},
	"missingplayers": [{{{MissingPlayers}}}]
}""";
		declare Request <=> Http.CreatePost(Private_MM_BuildAPIUrl("/status"), PostData);
		if (Request != Null) {
			G_Matchmaking_RequestsIds[Request.Id] = C_Request_PostStatus;
		}
		
		if (C_Matchmaking_Debug) MB_Log("[API] Request: POST /status\n"^PostData);
	}
}

// ---------------------------------- //
/** Ping the API
 *
 *	@param	_Forced		Skip the time interval and force the ping
 */
Void Private_MM_Ping(Boolean _Forced) {
	if (Now >= G_Match_NextPing || _Forced) {
		G_Match_NextPing = Now + C_Match_PingInterval;
		Private_MM_PostMatchStatus();
	}
}

// ---------------------------------- //
/** Change the match status
 *
 *	@param	_MatchStatus		The new match status
 */
Void Private_MM_SetMatchStatus(Integer _MatchStatus) {
	G_Match_Status = _MatchStatus;
	Private_MM_Ping(True);
}

// ---------------------------------- //
/// Send the get match request to the API
Void Private_MM_GetMatch() {
	if (!G_Matchmaking_RequestsIds.exists(C_Request_GetMatches)) {
		declare Request <=> Http.CreateGet(Private_MM_BuildAPIUrl("/match?serverlogin="^ServerLogin), False);
		if (Request != Null) {
			G_Matchmaking_RequestsIds[Request.Id] = C_Request_GetMatches;
		}
		
		if (C_Matchmaking_Debug) MB_Log("[API] Request: Get /match?serverlogin="^ServerLogin);
	}
}

// ---------------------------------- //
/// Manage players authorization
Void Private_MM_ManagePlayers() {
	declare PresentPlayers = Real[Text];
	declare ToKick = CUser[];
	
	foreach (Player in AllPlayers) {
		declare Matchmaking_PlayerStatus for Player = C_PlayerStatus_Waiting;
		
		// Change the status of the player
		if (Matchmaking_PlayerStatus == C_PlayerStatus_Waiting) {
			// Waiting match
			if (G_Match_Status == C_MatchStatus_Waiting) {
				Private_MM_GetMatch();
				SetPlayerClan(Player, 0);
			} 
			// Waiting substitute
			else if (G_Match_Status == C_MatchStatus_Substitute) {
				Private_MM_GetMatch();
			}
			// Match running normally
			else {
				if (G_Match_Players.existskey(Player.Login)) {
					Matchmaking_PlayerStatus = C_PlayerStatus_Valid;
					SetPlayerClan(Player, G_Match_Players[Player.Login]);
				} else {
					Matchmaking_PlayerStatus = C_PlayerStatus_Invalid;
				}
			}
		}
		
		// Kick the invalid players
		if (Matchmaking_PlayerStatus == C_PlayerStatus_Invalid) {
			if (!Player.User.IsFakeUser) {
				ToKick.add(Player.User);
			} else {
				declare UI <=> UIManager.GetUI(Player);
				if (UI != Null && !UI.ForceSpectator) {
					UI.ForceSpectator = True;
				}
			}
		}
		
		// Count players in each clan
		if (G_Match_Players.existskey(Player.Login)) {
			PresentPlayers[Player.Login] = Player.User.LadderPoints;
		}
	}
	
	foreach (User in ToKick) {
		Admin_KickUser(User, "You're not authorized on this match server.");
	}
	
	declare NewMissingPlayers = False;
	foreach (Login => Clan in G_Match_Players) {
		// Missing
		if (!PresentPlayers.existskey(Login)) {
			// New
			if (!G_Match_MissingPlayers.existskey(Login)) {
				G_Match_MissingPlayers[Login] = 0.;
				NewMissingPlayers = True;
			}
		}
	}
	
	// Inform the API of the missing players
	if (NewMissingPlayers) {
		Private_MM_SetMatchStatus(C_MatchStatus_Substitute);
	}
}

// ---------------------------------- //
/** Convert an echelon to an integer
 *
 *	@param	_Echelon	The echelon to convert
 *
 *	@return		The echelon converted to an Integer
 */
Integer ToInteger(CUser::EEchelon _Echelon) {
	switch (_Echelon) {
		case CUser::EEchelon::Bronze1	: return 1;
		case CUser::EEchelon::Bronze2	: return 2;
		case CUser::EEchelon::Bronze3	: return 3;
		case CUser::EEchelon::Silver1	: return 4;
		case CUser::EEchelon::Silver2	: return 5;
		case CUser::EEchelon::Silver3	: return 6;
		case CUser::EEchelon::Gold1		: return 7;
		case CUser::EEchelon::Gold2		: return 8;
		case CUser::EEchelon::Gold3		: return 9;
	}
	
	return 0;
}

// ---------------------------------- //
/** Add a player to the masters list
 *
 *	@param	_Player		The player to add
 *	@param	_Timestamp	The last time this player was a master
 */
Void Private_MM_AddMaster(CSmPlayer _Player, Integer _Timestamp) {
	if (_Player == Null || _Timestamp <= 0) return;
	
	// Check if the player is already in the masters list for the same match
	declare netwrite Integer Net_Lobby_MastersUpdate for Teams[0];
	declare netwrite Text[Integer][] Net_Lobby_Masters for Teams[0];
	declare CanBeAdded = True;
	foreach (Key => Login in G_Lobby_MastersLogins) {
		if (_Player.Login != Login) continue;
			
		if (Net_Lobby_Masters.existskey(Key)) {
			if (Net_Lobby_Masters[Key][C_Master_Timestamp] == MM_TL::ToText(_Timestamp)) {
				CanBeAdded = False;
				break;
			}
		} 
	}
	
	// Add the player to the masters
	if (CanBeAdded) {
		G_Lobby_MastersLogins.add(_Player.Login);
		Net_Lobby_Masters.add([
			C_Master_Timestamp	=> MM_TL::ToText(_Timestamp),
			C_Master_Name		=> _Player.Name,
			C_Master_Country	=> _Player.User.CountryFlagUrl,
			C_Master_Echelon	=> MM_TL::ToText(ToInteger(_Player.User.Echelon))
		]);
		Net_Lobby_MastersUpdate = Now;
	}
	
	// Remove masters when they are too much
	declare Key = C_Lobby_MastersNb;
	while (G_Lobby_MastersLogins.count > C_Lobby_MastersNb || Net_Lobby_Masters.count > C_Lobby_MastersNb) {
		declare Removed = G_Lobby_MastersLogins.removekey(0);
		Removed = Net_Lobby_Masters.removekey(0);
	}
}

// ---------------------------------- //
/** Parse the match request response and
 *	setup a match when necessary
 *
 *	@param	_MatchXml	Xml containing the match settings
 */
Void Private_MM_SetupMatch(Text _MatchXml) {
	if (C_Matchmaking_Debug) MB_Log("[API] Response: GET /match?serverlogin="^ServerLogin^"\n"^_MatchXml);
	if (_MatchXml != "") {
		declare XmlDoc <=> Xml.Create(_MatchXml);
		if (XmlDoc != Null && XmlDoc.Root != Null) {
			declare NodeMatch <=> XmlDoc.Root.GetFirstChild("match");
			
			if (NodeMatch != Null) {
				declare NodeServer <=> NodeMatch.GetFirstChild("server");
				declare NodePlayers <=> NodeMatch.GetFirstChild("players");
				declare MatchId = -1;
				declare MatchPlayers = Integer[Text];
				declare MatchLobbyLogin = "";
				
				MatchId = NodeMatch.GetAttributeInteger("id", -1);
				
				if (NodeServer != Null) {
					MatchLobbyLogin = NodeServer.GetAttributeText("lobby", "");
				}
				if (NodePlayers != Null) {
					foreach (NodePlayer in NodePlayers.Children) {
						declare Login = NodePlayer.GetAttributeText("login", "");
						declare Clan = NodePlayer.GetAttributeInteger("clan", -1);
						declare Replaced = NodePlayer.GetAttributeBoolean("replaced", False);
						
						if (Replaced) {
							declare Removed = G_Match_MissingPlayers.removekey(Login);
						} else {
							if (G_Matchmaking_Format.count > 1) Clan += 1;
							if (Login != "" && Clan >= 0) {
								MatchPlayers[Login] = Clan;
							}
						}
					}
				}
				
				// Match is valid, start preparation
				if (MatchId >= 0 && MatchPlayers.count > 0 && MatchLobbyLogin != "") {
					G_Match_Id = MatchId;
					G_Match_Players = MatchPlayers;
					G_Match_LobbyLogin = MatchLobbyLogin;
					
					Private_MM_SetMatchStatus(C_MatchStatus_Starting);
				}
			}
		}
	}
	
	// Kick all players from the server if there's no match starting
	if (G_Match_Status != C_MatchStatus_Starting) {
		foreach (Player in AllPlayers) {
			declare Matchmaking_PlayerStatus for Player = C_PlayerStatus_Waiting;
			Matchmaking_PlayerStatus = C_PlayerStatus_Invalid;
		}
	}
}

// ---------------------------------- //
/** Parse the match request response and
 *	setup the substitutes if necessary
 *
 *	@param	_MatchXml	Xml containing the match settings
 */
Void Private_MM_SetupSubstitute(Text _MatchXml) {
	if (C_Matchmaking_Debug) MB_Log("[API] Response: GET /match?serverlogin="^ServerLogin^"\n"^_MatchXml);
	if (_MatchXml != "") {
		declare XmlDoc <=> Xml.Create(_MatchXml);
		if (XmlDoc != Null && XmlDoc.Root != Null) {
			declare NodeMatch <=> XmlDoc.Root.GetFirstChild("match");
			
			if (NodeMatch != Null) {
				declare NodePlayers <=> NodeMatch.GetFirstChild("players");
				declare MatchId = -1;
				declare MatchPlayers = Integer[Text];
				
				MatchId = NodeMatch.GetAttributeInteger("id", -1);
				
				if (MatchId == G_Match_Id) {
					if (NodePlayers != Null) {
						foreach (NodePlayer in NodePlayers.Children) {
							declare Login = NodePlayer.GetAttributeText("login", "");
							declare Clan = NodePlayer.GetAttributeInteger("clan", -1);
							declare Replaced = NodePlayer.GetAttributeBoolean("replaced", False);
							
							if (Replaced) {
								declare Removed = G_Match_MissingPlayers.removekey(Login);
							} else {
								if (G_Matchmaking_Format.count > 1) Clan += 1;
								if (Login != "" && Clan >= 0) {
									MatchPlayers[Login] = Clan;
								}
							}
						}
					}
					
					G_Match_Players = MatchPlayers;
					if (G_Match_MissingPlayers.count <= 0) {
						Private_MM_SetMatchStatus(C_MatchStatus_Playing);
					} else {
						Private_MM_SetMatchStatus(C_MatchStatus_Substitute);
					}
				}
			}
		}
	}
	
	// Set invalid players
	foreach (Player in AllPlayers) {
		declare Matchmaking_PlayerStatus for Player = C_PlayerStatus_Waiting;
		if (!G_Match_Players.existskey(Player.Login)) {
			Matchmaking_PlayerStatus = C_PlayerStatus_Invalid;
		} else {
			Matchmaking_PlayerStatus = C_PlayerStatus_Valid;
		}
	}
}

// ---------------------------------- //
/** Parse the player request response and
 *	setup the player accordingly
 *
 *	@param	_PlayerXml	Xml containing the player info
 */
Void Private_MM_SetupPlayer(Text _PlayerXml) {
	if (C_Matchmaking_Debug) MB_Log("[API] Response: GET /player?login=xxx\n"^_PlayerXml);
	if (_PlayerXml != "") {
		declare XmlDoc <=> Xml.Create(_PlayerXml);
		if (XmlDoc != Null && XmlDoc.Root != Null) {
			declare NodePlayer <=> XmlDoc.Root.GetFirstChild("player");
			if (NodePlayer != Null) {
				declare Login = NodePlayer.GetAttributeText("login", "");
				declare Player <=> SM::GetPlayer(Login);
				
				// If the player was in match, send in back to his server
				declare NodeServer <=> NodePlayer.GetFirstChild("server");
				if (NodeServer != Null) {
					declare MatchServerLogin = NodeServer.GetAttributeText("match", "");
					if (Player != Null && MatchServerLogin != "") MM_SendToServer(Player, MatchServerLogin);
				}
				
				// If the player was a master add him to the list
				declare NodeMaster <=> NodePlayer.GetFirstChild("master");
				if (NodeMaster != Null) {
					declare Timestamp = NodeMaster.GetAttributeInteger("timestamp", -1);
					if (Player != Null && Timestamp > 0) Private_MM_AddMaster(Player, Timestamp);
				}
			}
		}
	}
}

// ---------------------------------- //
/// Manage the HTTP response from the API
Void Private_MM_ManageHttpResponses() {
	declare Ident[] ToRemove;
	foreach (Request in Http.Requests) {
		if (!G_Matchmaking_RequestsIds.existskey(Request.Id)) continue;
		
		if (Request.IsCompleted) {
			ToRemove.add(Request.Id);
		}
	}
	
	// Destroy the completed requests
	foreach (RequestId in ToRemove) {
		if (!Http.Requests.existskey(RequestId)) continue;
		declare Request <=> Http.Requests[RequestId];
		
		// Success
		if (Request.StatusCode == 200) {
			declare RequestType = G_Matchmaking_RequestsIds[Request.Id];
			switch (RequestType) {
				case C_Request_GetPlayers: {
					Private_MM_SetupPlayer(Request.Result);
				}
				case C_Request_GetMatches: {
					if (G_Match_Status == C_MatchStatus_Waiting) {
						Private_MM_SetupMatch(Request.Result);
					} else if (G_Match_Status == C_MatchStatus_Substitute) {
						Private_MM_SetupSubstitute(Request.Result);
					}
				}
			}
		}
		// Fail
		else {
			if (S_LogAPIError) {
				if (Request.StatusCode == 401) {
					MB_Log("[ERROR] Matchmaking HTTP API Error 401. Maybe the login or password in the setting is wrong.");
				} else if (Request.StatusCode == 404) {
					MB_Log("[ERROR] Matchmaking HTTP API Error 404. Maybe the URL in the setting is wrong.");
				} else {
					MB_Log("[ERROR] Matchmaking HTTP Error "^Request.StatusCode^".");
				}
			}
		}
			
		declare Removed = G_Matchmaking_RequestsIds.removekey(RequestId);
		Http.Destroy(Http.Requests[RequestId]);
	}
}

// ---------------------------------- //
/** Check if all the allies of a player are ready
 *
 *	@param	_Player		The player to check
 *
 */
Void Private_MM_AlliesAreReady(CSmPlayer _Player) {
	if (_Player == Null) return;
	
	declare Integer[Ident] Lobby_Allies for _Player;
	declare CPlayer[] PlayersToUpdate;
	declare Ready = True;
	
	// Am i ready ?
	declare Lobby_AlliesAreReady for _Player = False;
	if (_Player.User.RequestsSpectate) Ready = False;
	PlayersToUpdate.add(_Player);
	
	// My allies are ready ?
	foreach (AllyId => AllyStatus in Lobby_Allies) {
		if (AllyStatus == C_AllyStatus_Validated && AllPlayers.existskey(AllyId)) {
			declare Player <=> AllPlayers[AllyId];
			PlayersToUpdate.add(Player);
			if (Player.User.RequestsSpectate) Ready = False;
		}
	}
	
	// Set ready state
	foreach (Player in PlayersToUpdate) {
		declare Lobby_AlliesAreReady for Player = False;
		Lobby_AlliesAreReady = Ready;
		
		declare netwrite Net_Lobby_AlliesAreReady for Player = False;
		Net_Lobby_AlliesAreReady = Ready;
	}
}

// ---------------------------------- //
/** Request info about a connecting player
 *
 *	@param	_Player		The player who joined the server
 */
Void Private_Lobby_GetPlayerInfo(CSmPlayer _Player) {
	if (_Player == Null || Http.SlotsAvailable <= 0) return;
	// Send the request to the API
	declare Request <=> Http.CreateGet(Private_MM_BuildAPIUrl("/player?login="^MM_TL::URLEncode(_Player.Login)), False);
	if (Request != Null) G_Matchmaking_RequestsIds[Request.Id] = C_Request_GetPlayers;
	
	if (C_Matchmaking_Debug) MB_Log("[API] Request: GET /player?login="^_Player.Login);
}

// ---------------------------------- //
/// Update the lobby players list
Void Private_Lobby_UpdatePlayersList() {
	declare netwrite Integer Net_Lobby_PlayersListUpdate for Teams[0];
	Net_Lobby_PlayersListUpdate = Now;
}

// ---------------------------------- //
/// Find the allies of each player
Void Private_MM_ComputeAllies() {
	/*declare Ident[] Connected;
	declare Ident[] Disconnected;
	foreach (User in Users) {
		declare Lobby_LastUpdate for User = -1;
		declare Lobby_Disconnected for User = True;
		// Disconnection
		if (Lobby_LastUpdate < Now && !Lobby_Disconnected) {
			declare Integer[Ident] Lobby_Allies as MyAllies for User;
			Lobby_Disconnected = True;
			Disconnected.add(User.Id);
			foreach (AllyId => AllyStatus in MyAllies) {
				if (Users.existskey(AllyId)) {
					declare Integer[Ident] Lobby_Allies as HisAllies for Users[AllyId];
					if (HisAllies.existskey(User.Id)) {
						if (HisAllies[User.Id] == C_AllyStatus_Validated) {
							HisAllies[User.Id] = C_AllyStatus_Disconnected;
						} else {
							declare Removed HisAllies.removekey([User.Id);
						}
					}
				}
			}
		}
		// Connection
		else if (Lobby_LastUpdate >= Now && Lobby_Disconnected) {
			declare Integer[Ident] Lobby_Allies as MyAllies for User;
			Lobby_Disconnected = False;
			Connected.add(User.Id);
		}
	}
	
	foreach (User in Users) {
		declare Integer[Ident] Lobby_Allies as MyAllies for User;
		declare Lobby_Disconnected for User = True;
		
		// Add global allies to the local allies array
		foreach (AllyLogin in User.AlliesConnected) {
			declare Ally <=> SM::GetPlayer(AllyLogin);
			if (Ally != Null) {
				MyAllies[Ally.User.Id] = C_AllyStatus_Validated;
			}
		}
		
		// Sort allies, Validated and Sent first
		MyAllies = MyAllies.sort();
		
		// Count the number of valid allies
		declare Boolean Lobby_AlliesFull for User;
		declare AlliesCount = 0;
		declare MaxAllies = G_Matchmaking_MaxPlayers - 1;
		declare ToRemove = Ident[];
		declare NewStatus = Integer[Ident];
		foreach (AllyId => AllyStatus in MyAllies) {
			declare UpdatedStatus = AllyStatus;
			// Reconnect
			if (Connected.exists(AllyId)) {
				if (AllyStatus == C_AllyStatus_Disconnected) UpdatedStatus = C_AllyStatus_Validated;
				NewStatus[AllyId] = UpdatedStatus;
			}
			// Disconnect
			if (Disconnected.exists(AllyId)) {
				
			}
			if (UpdatedStatus == C_AllyStatus_Validated || UpdatedStatus == C_AllyStatus_Sent) {
				AlliesCount += 1;
				if (AlliesCount > MaxAllies) ToRemove.add(AllyId);
			}
		}
		if (AlliesCount >= MaxAllies) Lobby_AlliesFull = True;
		else Lobby_AlliesFull = False;
		
		// Remove allies
		foreach (AllyId in ToRemove) {
			declare Removed = MyAllies.removekey(AllyId);
		}
		
		// Update status
		foreach (AllyId => AllyStatus in NewStatus) {
			MyAllies[AllyId] = AllyStatus;
		}
		
		// Send allies to the UI
		declare Count = 0;
		if (!Lobby_Disconnected) {
			declare Player <=> SM::GetPlayer(User.Login);
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) {
				declare netwrite Integer[Text] Net_Lobby_AlliesLogins for UI;
				declare netwrite Integer Net_Lobby_AlliesLoginsUpdate for UI;
				Net_Lobby_AlliesLogins.clear();
				foreach (AllyId => AllyStatus in MyAllies) {
					if (
						(AllyStatus == C_AllyStatus_Validated || AllyStatus == C_AllyStatus_Sent)
						&& Users.existskey(AllyId)
					) {
						Net_Lobby_AlliesLogins[Users[AllyId].Login] = AllyStatus;
						Count += 1;
						if (Count >= MaxAllies) break;
					}
				}
				Net_Lobby_AlliesLoginsUpdate = Now;
			}
		}
	}*/
	
	foreach (Player in AllPlayers) {
		if (Player == Null) return;
		
		declare Integer[Ident] Lobby_Allies as MyAllies for Player;
		
		// Add global allies to the local allies array
		foreach (AllyLogin in Player.User.AlliesConnected) {
			declare Ally <=> SM::GetPlayer(AllyLogin);
			if (Ally != Null) {
				MyAllies[Ally.Id] = C_AllyStatus_Validated;
			}
		}
		
		// Sort allies, Validated and Sent first
		MyAllies = MyAllies.sort();
		
		// Count the number of valid allies
		declare Boolean Lobby_AlliesFull for Player;
		declare AlliesCount = 0;
		declare MaxAllies = G_Matchmaking_MaxPlayers - 1;
		declare ToRemove = Ident[];
		foreach (AllyId => AllyStatus in MyAllies) {
			if (!AllPlayers.existskey(AllyId)) {
				ToRemove.add(AllyId);
			} else if (AllyStatus == C_AllyStatus_Validated || AllyStatus == C_AllyStatus_Sent) {
				AlliesCount += 1;
				if (AlliesCount > MaxAllies) ToRemove.add(AllyId);
			}
		}
		if (AlliesCount >= MaxAllies) Lobby_AlliesFull = True;
		else Lobby_AlliesFull = False;
		foreach (AllyId in ToRemove) {
			declare Removed = MyAllies.removekey(AllyId);
		}
		
		// Check if my allies are ready
		Private_MM_AlliesAreReady(Player);
		
		declare Count = 0;
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			declare netwrite Integer[Text] Net_Lobby_AlliesLogins for UI;
			declare netwrite Integer Net_Lobby_AlliesLoginsUpdate for UI;
			Net_Lobby_AlliesLogins.clear();
			foreach (AllyId => AllyStatus in MyAllies) {
				if (
					(AllyStatus == C_AllyStatus_Validated || AllyStatus == C_AllyStatus_Sent)
					&& AllPlayers.existskey(AllyId)
				) {
					Net_Lobby_AlliesLogins[AllPlayers[AllyId].Login] = AllyStatus;
					Count += 1;
					if (Count >= MaxAllies) break;
				}
			}
			Net_Lobby_AlliesLoginsUpdate = Now;
		}
		
		// Update players list
		Private_Lobby_UpdatePlayersList();
	}
}

// ---------------------------------- //
/** Request an ally
 *
 *	@param	_Player		The player requesting the ally
 *	@param	_Ally		The requested ally
 */
Void Private_MM_RequestAlly(CSmPlayer _Player, CSmPlayer _Ally) {
	if (_Player == Null || _Ally == Null) return;
	if (_Player.Id == _Ally.Id) return;
	
	declare Integer[Ident] Lobby_Allies as MyAllies for _Player;
	declare Integer[Ident] Lobby_Allies as HisAllies for _Ally;
	declare Boolean Lobby_AlliesFull for _Player;
	
	// This ally exists in my list
	if (MyAllies.existskey(_Ally.Id) || HisAllies.existskey(_Player.Id)) {
		// Cancel my ally request
		if (MyAllies.existskey(_Ally.Id) && MyAllies[_Ally.Id] == C_AllyStatus_Sent) {
			declare Boolean Removed;
			Removed = MyAllies.removekey(_Ally.Id);
			Removed = HisAllies.removekey(_Player.Id);
		} 
		// Accept his ally request
		else if (HisAllies.existskey(_Player.Id) && HisAllies[_Player.Id] == C_AllyStatus_Sent) {
			// If I've already filled my allies slot I can't accept the request
			if (!Lobby_AlliesFull) {
				MyAllies[_Ally.Id] = C_AllyStatus_Validated;
				HisAllies[_Player.Id] = C_AllyStatus_Validated;
			}
		}
		// Cancel an ally agreement
		else if (MyAllies.existskey(_Ally.Id) && MyAllies[_Ally.Id] == C_AllyStatus_Validated) {
			declare Boolean Removed;
			Removed = MyAllies.removekey(_Ally.Id);
			HisAllies[_Player.Id] = C_AllyStatus_Sent;
		}
	}
	// This ally doesn't exists in my list
	else {
		// Send the request if I have enough allies slots left
		if (!Lobby_AlliesFull) {
			MyAllies[_Ally.Id] = C_AllyStatus_Sent;
		}
	}
	
	Private_MM_ComputeAllies();
}

// ---------------------------------- //
/// Matchmaking play loop
Void Private_MM_PlayLoop() {
	switch (G_Matchmaking_Mode) {
		case C_Matchmaking_Lobby: {
			Message::Loop();
			
			declare NeedAlliesUpdate = False;
			foreach (Player in AllPlayers) {
				declare Lobby_IsNew for Player = True;
				declare Lobby_PrevRequestsSpectate for Player = False;
				/*declare Lobby_LastUpdate for Player.User = -1;
				Lobby_LastUpdate = Now;*/
				
				// ---------------------------------- //
				// New player on the lobby
				if (Lobby_IsNew) {
					Lobby_IsNew = False;
					// Not ready players are sent in spectator mode
					Users_RequestSwitchToSpectator(Player.User);
					// Recompute allies when a new player join the lobby
					NeedAlliesUpdate = True;
					// Update players list
					Private_Lobby_UpdatePlayersList();
					// Request info on the player
					Private_Lobby_GetPlayerInfo(Player);
				}
				
				// ---------------------------------- //
				// Player change switch between players and spectators
				if (Lobby_PrevRequestsSpectate != Player.RequestsSpectate) {
					Lobby_PrevRequestsSpectate = Player.RequestsSpectate;
					//Private_Lobby_UpdatePlayersList();
					Private_MM_AlliesAreReady(Player);
					declare Integer Lobby_ReadySince for Player;
					Lobby_ReadySince = Now;
					
					// See if we need to cancel a match
					if (Player.RequestsSpectate) {
						MM_CancelMatch(Player.User);
					}
				}
			}
			
			foreach (Event in PendingEvents) {
				if (Event.Type == CSmModeEvent::EType::OnPlayerRemoved) {
					NeedAlliesUpdate = True;
					Private_Lobby_UpdatePlayersList();
					MM_CancelMatch(Event.User);
				} else if (Event.Type == CSmModeEvent::EType::OnPlayerAdded) {
					NeedAlliesUpdate = True;
					Private_Lobby_UpdatePlayersList();
				}
			}
			
			if (NeedAlliesUpdate) Private_MM_ComputeAllies();
		}
		case C_Matchmaking_Match: {
			Private_MM_Ping(False);
			Private_MM_ManagePlayers();
		}
	}
	
	Private_MM_ManageHttpResponses();
	if (G_Matchmaking_Mode != 0) {
		+++MatchmakingYield+++
	}
}

// ---------------------------------- //
/// Matchmaking yield
Void MM_Yield() {
	MB_Yield();
	Private_MM_PlayLoop();
}

// ---------------------------------- //
/** Get the clan selected by the matchmaking for the player
 *	If the server is not in matchmaking mode, return the default requested clan
 *
 *	@param	_Player		The player to check
 *
 *	@return		The matchmaking clan of the player
 */
Integer MM_GetRequestedClan(CSmPlayer _Player) {
	if (_Player == Null) return 0;
	
	if (S_MatchmakingMode != 2) return _Player.RequestedClan;
	
	if (G_Match_Players.existskey(_Player.Login)) {
		return G_Match_Players[_Player.Login];
	}
	
	return 0;
}

// ---------------------------------- //
/** Get the status of a player
 *	One of these values can be returned
 *	- C_PlayerStatus_Waiting
 *	- C_PlayerStatus_Valid
 *	- C_PlayerStatus_Invalid
 *
 *	@param	_Player		The player to check
 *
 *	@return		The player status
 */
Integer MM_GetPlayerStatus(CSmPlayer _Player) {
	if (_Player == Null) return C_PlayerStatus_Invalid;
	
	declare Matchmaking_PlayerStatus for _Player = C_PlayerStatus_Waiting;
	return Matchmaking_PlayerStatus;
}

// ---------------------------------- //
/// Prepare a new match
Void Private_MM_PrepareMatch() {
	StartTime = Now;
	UIManager.UIAll.CountdownEndTime = StartTime + C_Match_PreparationDuration;
	
	declare ReqPlayersNb = 0;
	foreach (PlayersNb in G_Matchmaking_Format) ReqPlayersNb += PlayersNb;
	
	declare netwrite Integer Net_MM_ReadyPlayersNb for Teams[0];
	declare netwrite Integer Net_MM_ReadyPlayersMax for Teams[0];
	Net_MM_ReadyPlayersNb = 0;
	Net_MM_ReadyPlayersMax = ReqPlayersNb;
	
	Layers::Attach("StartingMatch");
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::RollingBackgroundIntro;
	
	while (G_Match_Status == C_MatchStatus_Starting && !ServerShutdownRequested && !MatchEndRequested) {
		MM_Yield();
		
		declare ReadyPlayersNb = 0;
		foreach (Player in AllPlayers) {
			declare Matchmaking_PlayerStatus for Player = C_PlayerStatus_Waiting;
			if (Matchmaking_PlayerStatus == C_PlayerStatus_Valid) {
				ReadyPlayersNb += 1;
			}
		}
		if (Net_MM_ReadyPlayersNb != ReadyPlayersNb) Net_MM_ReadyPlayersNb = ReadyPlayersNb;
		
		+++MatchmakingMatchPrepare+++
		
		if (Now >= UIManager.UIAll.CountdownEndTime || ReadyPlayersNb >= ReqPlayersNb) {
			Private_MM_SetMatchStatus(C_MatchStatus_Playing);
		}
	}
	
	Layers::Detach("StartingMatch");
	StartTime = -1;
	UIManager.UIAll.CountdownEndTime = -1;
}

// ---------------------------------- //
/// Wait for a new match
Void MM_MatchWait() {
	G_Match_Players.clear();
	G_Match_Id = -1;
	G_Match_LobbyLogin = "";
	G_Match_MissingPlayers.clear();
	
	Private_MM_SetMatchStatus(C_MatchStatus_Waiting);
	
	// Waiting to get a match
	while (G_Match_Status == C_MatchStatus_Waiting && !ServerShutdownRequested && !MatchEndRequested) {
		MM_Yield();
		
		+++MatchmakingMatchWait+++
	}
	
	// Got a match, now prepare it
	Private_MM_PrepareMatch();
	
}

// ---------------------------------- //
/** Send the match result to the API
 *
 *	@param	_Master		The master of the match
 */
Void MM_MatchResult(Text _MasterLogin) {
	if (Http.SlotsAvailable > 0) {
		declare PostData = """
{
	"matchid": {{{G_Match_Id}}},
	"master": "{{{_MasterLogin}}}"
}""";
		declare Request <=> Http.CreatePost(Private_MM_BuildAPIUrl("/result"), PostData);
		if (Request != Null) {
			G_Matchmaking_RequestsIds[Request.Id] = C_Request_PostResults;
		}
		
		if (C_Matchmaking_Debug) MB_Log("[API] Request: POST /result\n"^PostData);
	}
}

// ---------------------------------- //
/// End a match
Void MM_MatchEnd() {
	Private_MM_SetMatchStatus(C_MatchStatus_Ending);
	
	foreach (Player in AllPlayers) {
		declare Matchmaking_PlayerStatus for Player = C_PlayerStatus_Waiting;
		if (Matchmaking_PlayerStatus == C_PlayerStatus_Valid) {
			MM_SendToServer(Player, G_Match_LobbyLogin);
		}
	}
	
	StartTime = Now;
	UIManager.UIAll.CountdownEndTime = StartTime + C_Match_EndingDuration;
	while (UIManager.UIAll.CountdownEndTime > Now) {
		MM_Yield();
	}
	StartTime = -1;
	UIManager.UIAll.CountdownEndTime = -1;
	
	G_Match_Players.clear();
	G_Match_Id = -1;
	G_Match_LobbyLogin = "";
	G_Match_MissingPlayers.clear();
}

// ---------------------------------- //
/** Custom sleep function
 *
 *	@param	_Duration	The time to spend sleeping in ms
 */
Void MM_Sleep(Integer _Duration) {
	declare End = Now + _Duration;
	while (Now < End && !ServerShutdownRequested && !MatchEndRequested) {
		MM_Yield();
		+++SleepLoop+++
		+++MatchmakingSleepLoop+++
	}
}

// ---------------------------------- //
/// Do the player presentation sequence (aka versus screen)
Void MM_PlayersPresentationSequence(Integer _Duration) {
	Clublink::SyncUpdate();
	
	declare End = Now + _Duration;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::PlayersPresentation;
	while (Now < End && !ServerShutdownRequested && !MatchEndRequested) {
		MM_Yield();
		+++PlayersPresentationLoop+++
		+++MatchmakingPlayersPresentationLoop+++
	}
}

// ---------------------------------- //
/// Overload of the MM_PlayersPresentationSequence() function
Void MM_PlayersPresentationSequence() {
	MM_PlayersPresentationSequence(C_PlayersPresentationTime);
}

// ---------------------------------- //
/** Load a scores table style from an XML file
 *
 *	@param	_Path		Path to the XML file
 */
Void MM_SetScoresTableStyleFromXml(Text _Path) {
	if (_Path == "") return;
	
	declare Loaded = ST2::RequestStyleFromXml(_Path);
	if (Loaded) {
		while (ST2::WaitStyleFromXml() && !ServerShutdownRequested && !MatchEndRequested) {
			MM_Yield();
		}
		Loaded = ST2::SetStyleFromXml(True);
	}
}

// ---------------------------------- //
/** Reset the combo of a player
 *
 *	@param	_Player		The player to reset
 */
Void Private_Lobby_ResetPlayer(CSmPlayer _Player) {
	if (_Player == Null) return;
	declare Integer Lobby_CurrentCombo for _Player = 0;
	Lobby_CurrentCombo  = 0;
}

// ---------------------------------- //
/// Reinitialize all the players
Void Private_Lobby_ReinitPlayers() {
	foreach (Player in AllPlayers) {
		Private_Lobby_ResetPlayer(Player);
		Player.Armor = Player.ArmorMax;
	}
}

// ---------------------------------- //
/// Spawn the players
Void Private_Lobby_SpawnPlayers() {
	foreach (Player in Players) {
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
			declare Boolean SpawnThePlayer = True;
			
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) {
				declare netread Boolean Net_Lobby_RollingIntro for UI;				
				SpawnThePlayer = !Net_Lobby_RollingIntro;
			}
			
			declare Lobby_OnVersusScreen for Player = False;
			SpawnThePlayer = !Lobby_OnVersusScreen;
			
			if (SpawnThePlayer || UI == Null) {
				if (S_LobbyInstagib) {
					SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
				}
				SM::SpawnPlayer(Player, 0, MapLandmarks_PlayerSpawn[MM_ML::Rand(0, MapLandmarks_PlayerSpawn.count - 1)].PlayerSpawn, Now);
				Private_Lobby_ResetPlayer(Player);
			}
		}
	}
}

// ---------------------------------- //
/** Display a message to a player when he beats his best combo
 *
 *	@param	_Player		The player who'll receive the message
 */
Void Private_Lobby_ShowScore(CSmPlayer _Player) {
	if (_Player == Null || _Player.Score == Null) return;

	declare Message = "";
	if (_Player.Score.Points <= 1) {
		Message = MM_TL::Compose( _("%1 point (Best score: %2)"), MM_TL::ToText(_Player.Score.Points), ""^G_Lobby_BestCombo);
	} else {
		Message = MM_TL::Compose( _("%1 points (Best score: %2)"), MM_TL::ToText(_Player.Score.Points), ""^G_Lobby_BestCombo);
	}
	
	Message::SendStatusMessage(_Player, Message, 3000, 2);
}

// ---------------------------------- //
/** Count points and display an hit notice to the shooter
 *
 *	@param	_Shooter	The player who shot and hit
 *
 *	@return		The number of points earned on this hit
 */
Integer Private_Lobby_NotifyHit(CSmPlayer _Shooter)  {
	if (_Shooter == Null || _Shooter.Score == Null) return 0;
	
	declare Lobby_CurrentCombo for _Shooter = 0;
	declare PointsEarned = 1 + (Lobby_CurrentCombo / 2);
	_Shooter.Score.Points += PointsEarned;
	Lobby_CurrentCombo += 1;
	
	if (_Shooter.Score.Points > G_Lobby_BestCombo) {
		G_Lobby_BestCombo = _Shooter.Score.Points;
		G_Lobby_WinnerId = _Shooter.User.Id;
	}
	
	Private_Lobby_ShowScore(_Shooter);
	
	return PointsEarned;
}

// ---------------------------------- //
/// Update the timers
Void Private_Lobby_UpdateTimers() {
	declare netwrite Integer	Net_Lobby_TimerMax	for Teams[0];
	declare netwrite Integer	Net_Lobby_Timer		for Teams[0];
	declare netwrite Boolean	Net_Lobby_AutoDown	for Teams[0];
	declare netwrite Integer	Net_Lobby_TimeDown	for Teams[0];
	
	Net_Lobby_TimerMax = G_Lobby_EndTime - G_Lobby_StartTime;
	Net_Lobby_Timer = Now - G_Lobby_StartTime;
	
	if (G_Lobby_Phase == C_Lobby_Playing) {
		Net_Lobby_AutoDown = False;
		Net_Lobby_TimeDown = 0;
	}
}

// ---------------------------------- //
/** Revert the timers
 *
 *	@param	_Duration		Duration of the reversal
 */
Void Private_Lobby_SetTimersAutoDown(Integer _Duration) {
	declare netwrite Integer	Net_Lobby_TimerMax	for Teams[0];
	declare netwrite Integer	Net_Lobby_Timer		for Teams[0];
	declare netwrite Boolean	Net_Lobby_AutoDown	for Teams[0];
	declare netwrite Integer	Net_Lobby_TimeDown	for Teams[0];
	
	Net_Lobby_TimerMax = 0;
	Net_Lobby_Timer = 0;
	Net_Lobby_AutoDown = True;
	Net_Lobby_TimeDown = _Duration;
}

// ---------------------------------- //
/// Update the UI
Void Private_Lobby_UpdateUI() {
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			// Spectators
			if (Player.RequestsSpectate) {
				declare netwrite Boolean Net_Lobby_ShowRules for UI;
				Net_Lobby_ShowRules = False;
	
				if (UI.UISequence != CUIConfig::EUISequence::RollingBackgroundIntro) {
					UI.UISequence = CUIConfig::EUISequence::RollingBackgroundIntro;
				}
			} 
			// Players
			else {
				declare netwrite Boolean Net_Lobby_ShowRules for UI;
				declare netread Boolean Net_Lobby_RollingIntro for UI;
				Net_Lobby_ShowRules = Net_Lobby_RollingIntro;
				
				if (!Net_Lobby_RollingIntro) {
					if (UI.UISequence != CUIConfig::EUISequence::Playing) {
						UI.UISequence = CUIConfig::EUISequence::Playing;
					}
				} else {
					if (UI.UISequence != CUIConfig::EUISequence::RollingBackgroundIntro) {
						UI.UISequence = CUIConfig::EUISequence::RollingBackgroundIntro;
						if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
							UnspawnPlayer(Player);
						}
					}
				}
			}
			// All
			declare netread Integer Net_Lobby_RequestAllyUpdate for UI;
			declare Lobby_PrevRequestAllyUpdate for Player = -1;
			if (Lobby_PrevRequestAllyUpdate != Net_Lobby_RequestAllyUpdate) {
				Lobby_PrevRequestAllyUpdate = Net_Lobby_RequestAllyUpdate;
				
				declare netread Text Net_Lobby_RequestAlly for UI;
				if (Net_Lobby_RequestAlly != "" && Net_Lobby_RequestAlly != Player.Login) {
					declare NewAlly <=> SM::GetPlayer(Net_Lobby_RequestAlly);
					if (NewAlly != Null) {
						Private_MM_RequestAlly(Player, NewAlly);
					}
				}
			}
		}
	}
}

// ---------------------------------- //
/** Create the rules reminder manialink
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLRulesReminder() {
	declare Text ImgBaseDir			= "file://Media/Manialinks/Shootmania/Common/";
	declare Text WelcomeBgImage		= ImgBaseDir^"WelcomeBg.dds";

	declare Text TitleText			= _("Waiting for your match to start");
	declare Text ModeName			= _("Lobby");
			
	declare Text RulesReminder		= MM_TL::Compose("$<%1%2$>\n\n%3\n$<%11. $>%4\n$<%12. $>%5", "$"^SpawnScreen::GetModeColor(), _("You will soon be redirected to a match server."), _("While waiting, try to become the King Of The Lobby!"), _("Perform as many hits as possible: the points you earn for each one will increase."), _("Your combo falls back to 1 when you are eliminated."));
	
	declare Text DoNotShowAgain		= _("Do Not Show Again");
	declare Text Close				= _("Close");
	
	declare Integer	WindowWidth		= 192;
	declare Integer	WindowHeight	= 38;
	declare Real	WindowX			= 0.;
	declare Real	WindowY			= 5.;
	
	return """
<frame id="RulesReminderMainFrame" posn="{{{WindowX}}} {{{WindowY}}} 0" hidden="true" >
	<format  textemboss="1" />
	<quad  posn="0 -2" 	sizen="210 65" halign="center"	valign="center"  image="{{{WelcomeBgImage}}}" />
	<label posn="0 {{{(WindowHeight/2)-3}}}" 	halign="center" valign="center" text="{{{TitleText}}}"  textsize="5" />
	<label posn="{{{-(WindowWidth/2)+2}}} {{{(WindowHeight/2)-12}}}" 	halign="left" valign="center" text="{{{RulesReminder}}}" textsize="2"/>
		<label posn="{{{(WindowWidth/2)-2}}} {{{-(WindowHeight/2)+2}}}" 	halign="right" valign="center" text="{{{DoNotShowAgain}}}" style="CardButtonSmall" ScriptEvents="true" id="Button_DoNotShowAgain" />
		<label posn="{{{(WindowWidth/2)-42}}} {{{-(WindowHeight/2)+2}}}" 	halign="right" valign="center" text="{{{Close}}}" style="CardButtonSmall" ScriptEvents="true" id="Button_Close" />
</frame>
<script><!--
main() {
	while (InputPlayer == Null) yield;
	
	// for the "do not show again" feature
	declare persistent Boolean NadeoKoL_PersistentShowRulesReminder for This = True;
	//NadeoKoL_PersistentShowRulesReminder = True;
	
	declare netwrite Boolean Net_Lobby_RollingIntro for UI;
	declare netread Boolean Net_Lobby_ShowRules for UI;
	
	if (!NadeoKoL_PersistentShowRulesReminder) {
		Net_Lobby_RollingIntro = False;
		return;
	}
	Net_Lobby_RollingIntro = True;
	
	declare Button_DoNotShowAgain <=> (Page.GetFirstChild("Button_DoNotShowAgain") as CMlLabel);
	declare Button_Close <=> (Page.GetFirstChild("Button_Close") as CMlLabel);
	declare RulesReminderMainFrame <=> (Page.GetFirstChild("RulesReminderMainFrame") as CMlFrame);

	while (True) {
		yield;
		
		if (Net_Lobby_ShowRules) {
			RulesReminderMainFrame.Show();
		} else {
			RulesReminderMainFrame.Hide();
		}

		foreach (Event in PendingEvents) {
			switch (Event.Type){
				case CMlEvent::Type::MouseClick: {
					if (Event.ControlId == "Button_DoNotShowAgain") {
						NadeoKoL_PersistentShowRulesReminder = False;
						Net_Lobby_RollingIntro = False;
					}
					if (Event.ControlId == "Button_Close") {
						Net_Lobby_RollingIntro = False;
					}
				}
			}
		}
	}
}
--></script>
""";
}

// ---------------------------------- //
/** Create the gauge timer manialink
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLGaugeTimer() {
	return """
<frame posn="0 69 2">
	<gauge posn="0 6.3" sizen="90 7" halign="center" valign="center" drawbg="false" id="Gauge_Timer" />
	<label posn="0 0" sizen="90 7" halign="center" valign="center" style="TextRaceChrono" textsize="6" textcolor="f90d" id="Label_WaitTime" />
</frame>
<script><!--
	#Include "TextLib" as TextLib

	main() {
		declare Gauge_Timer		<=> (Page.GetFirstChild("Gauge_Timer")		as CMlGauge);
		declare Label_WaitTime	<=> (Page.GetFirstChild("Label_WaitTime")	as CMlLabel);

		declare netread Integer	Net_Lobby_TimerMax	for Teams[0];
		declare netread Integer	Net_Lobby_Timer		for Teams[0];
		declare netread Boolean	Net_Lobby_AutoDown	for Teams[0];
		declare netread Integer	Net_Lobby_TimeDown	for Teams[0];
		
		declare Integer WaitingTime = 0;
		
		declare Integer Period;
		declare Integer PrevNow = Now;
		
		while (True) {
			sleep(50);
			Period = Now - PrevNow;
			PrevNow = Now;
			
			if (Net_Lobby_AutoDown && Net_Lobby_TimeDown != 0) {
				declare Real SpeedDown = (1. * Period)  / (1.* Net_Lobby_TimeDown);
				if ((Gauge_Timer.Ratio - SpeedDown) < 0) Gauge_Timer.Ratio = 0.;
				else Gauge_Timer.Ratio -= SpeedDown;
			} else {
				if (Net_Lobby_TimerMax > 0) {
					declare Real Ratio = (1. * Net_Lobby_Timer) / Net_Lobby_TimerMax;
					if(Ratio < 0.) Ratio = 0.;
					if(Ratio > 1.) Ratio = 1.;
					Gauge_Timer.Ratio = Ratio;
				}
			}
			
			if (IsSpectatorMode) {
				Label_WaitTime.Hide();
				WaitingTime = 0;
			} else {
				WaitingTime += Period;
				Label_WaitTime.Show();					
				Label_WaitTime.SetText(TextLib::TimeToText(WaitingTime));
			}
		}
	}
--></script>
""";
}

// ---------------------------------- //
/** Create the waiting screen manialink
 *
 *	@param	_DisplayRules		Allow to display a manialink with the rules of the mode
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLWaitingScreen(Boolean _DisplayRules) {
	declare SizeX = 141.;
	declare SizeY = 99.;
	
	declare Background_Global = "file://Media/Manialinks/Common/Lobbies/main-bg.png";
	declare Background_OccupiedSlot = "file://Media/Manialinks/Common/Lobbies/PlayerCardBg.dds";
	declare Echelon0 = "file://Media/Manialinks/Common/Echelons/echelon0.dds";
	declare ButtonQuitOn = "file://Media/Manialinks/Common/Lobbies/small-button-RED-ON.dds";
	declare ButtonQuitOff = "file://Media/Manialinks/Common/Lobbies/small-button-RED.dds";
	declare ButtonRulesOn = "file://Media/Manialinks/Common/Lobbies/small-button-YELLOW-ON.dds";
	declare ButtonRulesOff = "file://Media/Manialinks/Common/Lobbies/small-button-YELLOW.dds";
	declare ButtonReadyOn = "file://Media/Manialinks/Common/Lobbies/ready-button-GREEN-ON.dds";
	declare ButtonReadyOff = "file://Media/Manialinks/Common/Lobbies/ready-button-GREEN.dds";
	declare ButtonInviteOn = "file://Media/Manialinks/Common/Lobbies/small-button-BLUE-ON.dds";
	declare ButtonInviteOff = "file://Media/Manialinks/Common/Lobbies/small-button-BLUE.dds";
	
	declare ButtonRules = "";
	if (_DisplayRules) {
		ButtonRules = """
<frame posn="0 -25 1" id="Frame_Rules">
	<quad sizen="35 10" halign="center" valign="center" image="{{{ButtonRulesOff}}}" imagefocus="{{{ButtonRulesOn}}}" scriptevents="1" id="Button_Rules" />
	<label sizen="35 10" scale="0.95" halign="center" valign="center2" style="TextRaceMessageBig" opacity="0.8" textsize="2" text="{{{_("Rules")}}}" />
</frame>""";
	}
	
	declare PlayersList = "";
	declare SlotsNb = 6;
	for (I, 0, SlotsNb-1) {
		declare PosY = I * -23;
		PlayersList^= """
<frame class="Frame_PlayerCard" hidden="1" id="{{{I+1}}}">
	<frameinstance modelid="Framemodel_EmptySlot" />
	<frameinstance modelid="Framemodel_OccupiedSlot" />
</frame>""";
	}
	
	return """
<framemodel id="Framemodel_EmptySlot">
	<frame id="Frame_EmptySlot">
		<quad sizen="80 20 -1" halign="center" valign="center" style="Bgs1" substyle="BgListLine" />
		<label sizen="75 4" halign="center" valign="center2" style="TextButtonSmall" text="{{{_("Picked by matchmaking")}}}" />
	</frame>
</framemodel>
<framemodel id="Framemodel_OccupiedSlot">
	<frame posn="-40 10" hidden="1" id="Frame_OccupiedSlot">
		<quad sizen="80 20 -1" image="{{{Background_OccupiedSlot}}}" />
		<quad posn="0.75 -10 1" sizen="18.5 18.5" valign="center" bgcolor="aaa" id="Quad_Avatar" />
		<label posn="22 -4" sizen="38 4" style="TextRaceMessage" textsize="3.5" id="Label_Name" />
		<label posn="27 -15" sizen="30 4" valign="center2" style="TextRaceMessage" textsize="1" id="Label_Rank" />
		<quad posn="22 -15" sizen="4 4" valign="center" id="Quad_CountryFlag" />
		<frame posn="72 0 1" scale="1.13">
			<quad sizen="14.1551 17.6938" halign="center" image="{{{Echelon0}}}" id="Quad_Echelon" />
			<label posn="0 -3.6" sizen="14 0" halign="center" style="TextRaceMessage" textsize="0.5" text="Echelon" />
			<label posn="0 -10.6" sizen="10 10" halign="center" valign="center" style="TextRaceMessageBig" text="0" id="Label_Echelon" />
		</frame>
		<quad posn="0 0 3" sizen="80 20" bgcolor="333a" hidden="1" id="Quad_AllyNotValidated" />
		<quad posn="0 0" sizen="80 20" scriptevents="1" id="Button_Player" />
	</frame>
</framemodel>
<frame posn="0 0 10" id="Frame_Global">
	<quad sizen="{{{SizeX}}} {{{SizeY}}} -1" halign="center" valign="center" image="{{{Background_Global}}}" />
	<label posn="0 38" sizen="{{{SizeX}}} 4" scale="0.9" halign="center" valign="top" textsize="2.5" autonewline="1" opacity="0.9" id="Label_Title" />
	<frame posn="0 18 1" scale="0.6" id="Frame_PlayerList">
		{{{PlayersList}}}
	</frame>
	<frame posn="0 4 1" id="Frame_Pager">
		<quad posn="-52" sizen="9 9" halign="right" valign="center" style="Icons64x64_1" substyle="ArrowPrev" scriptevents="1" id="Button_PagerPrev" />
		<quad posn="52 0" sizen="9 9" valign="center" style="Icons64x64_1" substyle="ArrowNext" scriptevents="1" id="Button_PagerNext" />
	</frame>
	<frame posn="-47 -36 1" id="Frame_ButtonQuit">
		<quad sizen="35 10" halign="center" valign="center" image="{{{ButtonQuitOff}}}" imagefocus="{{{ButtonQuitOn}}}" action="maniaplanet:quitserver" />
		<label sizen="35 10" scale="0.95" halign="center" valign="center2" style="TextRaceMessageBig" opacity="0.8" textsize="2" text="{{{_("Quit")}}}" id="Label_Quit" />
	</frame>
	{{{ButtonRules}}}
	<frame posn="0 -36 1" id="Frame_Ready">
		<quad sizen="48 12" halign="center" valign="center" image="{{{ButtonReadyOff}}}" imagefocus="{{{ButtonReadyOn}}}" action="maniaplanet:togglespec" />
		<label sizen="48 12" halign="center" valign="center2" style="TextRaceMessageBig" opacity="0.8" textsize="2.5" text="{{{_("Ready (F6)")}}}" />
	</frame>
	<frame posn="47 -36 1" id="Frame_Invite">
		<quad sizen="35 10" halign="center" valign="center" image="{{{ButtonInviteOff}}}" imagefocus="{{{ButtonInviteOn}}}" manialink="elite-invite" />
		<label sizen="35 10" scale="0.95" halign="center" valign="center2" style="TextRaceMessageBig" opacity="0.8" textsize="2" text="{{{_("Invite")}}}" />
	</frame>
	<quad posn="0 -90" sizen="80 20" halign="center" valign="bottom" id="Quad_Logo" />
</frame>
<script><!--
#Include "TextLib" as TL

declare Integer G_PageStart;
declare Integer G_PlayersMax;

Integer GetEchelon(CUser::EEchelon _Echelon) {
	switch (_Echelon) {
		case CUser::EEchelon::Bronze1	: return 1;
		case CUser::EEchelon::Bronze2	: return 2;
		case CUser::EEchelon::Bronze3	: return 3;
		case CUser::EEchelon::Silver1	: return 4;
		case CUser::EEchelon::Silver2	: return 5;
		case CUser::EEchelon::Silver3	: return 6;
		case CUser::EEchelon::Gold1		: return 7;
		case CUser::EEchelon::Gold2		: return 8;
		case CUser::EEchelon::Gold3		: return 9;
	}
	
	return 0;
}

Text GetEchelonPath(CUser::EEchelon _Echelon) {
	return "file://Media/Manialinks/Common/Echelons/echelon"^GetEchelon(_Echelon)^".dds";
}

CUser GetUser(Text _Login) {
	foreach (Player in Players) {
		if (Player.Login == _Login) return Player.User;
	}
	
	return Null;
}

Void UpdateOccupiedSlot(CMlFrame _Frame, CUser _User) {
	if (_Frame == Null || _User == Null) return;
	
	declare Quad_Avatar			<=> (_Frame.GetFirstChild("Quad_Avatar")		as CMlQuad);
	declare Label_Name			<=> (_Frame.GetFirstChild("Label_Name")			as CMlLabel);
	declare Label_Rank			<=> (_Frame.GetFirstChild("Label_Rank")			as CMlLabel);
	declare Quad_CountryFlag	<=> (_Frame.GetFirstChild("Quad_CountryFlag")	as CMlQuad);
	declare Quad_Echelon		<=> (_Frame.GetFirstChild("Quad_Echelon")		as CMlQuad);
	declare Label_Echelon		<=> (_Frame.GetFirstChild("Label_Echelon")		as CMlLabel);
	declare Button_Player		<=> (_Frame.GetFirstChild("Button_Player")		as CMlQuad);
	
	if (Quad_Avatar != Null)		Quad_Avatar.ImageUrl = "file://Avatars/"^_User.Login^"/Default";
	if (Label_Name != Null)			Label_Name.Value = _User.Name;
	if (Quad_CountryFlag != Null)	Quad_CountryFlag.ImageUrl = _User.CountryFlagUrl;
	if (Quad_Echelon != Null)		Quad_Echelon.ImageUrl = GetEchelonPath(_User.Echelon);
	if (Label_Echelon != Null)		Label_Echelon.Value = TL::ToText(GetEchelon(_User.Echelon));
	if (Label_Rank != Null) {
		declare Zone = _("Other");
		declare ZoneArray = TL::Split("|", _User.LadderZoneName);
		if (ZoneArray.existskey(2)) Zone = ZoneArray[2];
		if (_User.LadderRank > 0) Label_Rank.Value = TL::Compose("%1: %2", Zone, TL::ToText(_User.LadderRank));
		else Label_Rank.Value = TL::Compose("%1: %2", Zone, _("Not ranked"));
	}
	
	declare Text Lobby_PlayerLogin for Button_Player;
	Lobby_PlayerLogin = _User.Login;
}

Void UpdateAllies() {
	declare netread Integer[Text] Net_Lobby_AlliesLogins for UI;
	
	declare Logins = Text[];
	declare Statuses = Integer[];
	foreach (Login => Status in Net_Lobby_AlliesLogins) {
		Logins.add(Login);
		Statuses.add(Status);
	}
	
	declare Frame_PlayerList <=> (Page.GetFirstChild("Frame_PlayerList") as CMlFrame);
	Page.GetClassChildren("Frame_PlayerCard", Frame_PlayerList, True);
	foreach (Control in Page.GetClassChildren_Result) {
		declare Count = G_PageStart + TL::ToInteger(Control.ControlId);
		
		declare Frame_PlayerCard	<=> (Control as CMlFrame);
		declare Frame_EmptySlot		<=> (Frame_PlayerCard.GetFirstChild("Frame_EmptySlot")		as CMlFrame);
		declare Frame_OccupiedSlot	<=> (Frame_PlayerCard.GetFirstChild("Frame_OccupiedSlot")	as CMlFrame);
		declare Quad_AllyNotValidated	<=> (Frame_OccupiedSlot.GetFirstChild("Quad_AllyNotValidated")	as CMlQuad);
		
		if (Count == 1) {
			Frame_EmptySlot.Visible = False;
			Frame_OccupiedSlot.Visible = True;
			Quad_AllyNotValidated.Visible = False;
			UpdateOccupiedSlot(Frame_OccupiedSlot, InputPlayer.User);
		} else if (Logins.existskey(Count-2)) {
			Frame_EmptySlot.Visible = False;
			Frame_OccupiedSlot.Visible = True;
			if (Statuses[Count-2] == {{{C_AllyStatus_Validated}}}) {
				Quad_AllyNotValidated.Visible = False;
			} else {
				Quad_AllyNotValidated.Visible = True;
			}
			UpdateOccupiedSlot(Frame_OccupiedSlot, GetUser(Logins[Count-2]));
		} else if (Count > G_PlayersMax) {
			Frame_EmptySlot.Visible = False;
			Frame_OccupiedSlot.Visible = False;
		} else {
			Frame_EmptySlot.Visible = True;
			Frame_OccupiedSlot.Visible = False;
		}
	}
}

Void UpdatePager(Integer _Shift) {
	declare Frame_Pager <=> (Page.GetFirstChild("Frame_Pager") as CMlFrame);
	if (G_PlayersMax > {{{SlotsNb}}}) {
		Frame_Pager.Visible = True;
	} else if (G_PlayersMax <= {{{SlotsNb}}}) {
		Frame_Pager.Visible = False;
		G_PageStart = 0;
	}
	
	declare NewPageStart = G_PageStart + (_Shift * {{{SlotsNb}}});
	if (NewPageStart < 0) NewPageStart = 0;
	else if (NewPageStart > G_PlayersMax - 1) NewPageStart = G_PageStart;
	G_PageStart = NewPageStart;
	if (G_PageStart > G_PlayersMax) G_PageStart = G_PlayersMax - 1;
	
	declare Button_PagerNext <=> (Frame_Pager.GetFirstChild("Button_PagerNext") as CMlQuad);
	declare Button_PagerPrev <=> (Frame_Pager.GetFirstChild("Button_PagerPrev") as CMlQuad);
	if (G_PageStart <= 0) Button_PagerPrev.Substyle = "ArrowDisabled";
	else Button_PagerPrev.Substyle = "ArrowPrev";
	if (G_PageStart + {{{SlotsNb}}} >= G_PlayersMax) Button_PagerNext.Substyle = "ArrowDisabled";
	else Button_PagerNext.Substyle = "ArrowNext";
	
	UpdateAllies();
}

Void UpdateFormat(Integer[] _Format) {
	declare Max = 0;
	foreach (PlayersNb in _Format) {
		if (PlayersNb > Max) Max = PlayersNb;
	}
	G_PlayersMax = Max;
	
	declare Frame_PlayerList <=> (Page.GetFirstChild("Frame_PlayerList") as CMlFrame);
	Page.GetClassChildren("Frame_PlayerCard", Frame_PlayerList, True);
	declare X = 0;
	declare Y = 0;
	foreach (Control in Page.GetClassChildren_Result) {
		declare Count = TL::ToInteger(Control.ControlId);
		
		if (Count > Max) Control.Visible = False;
		else Control.Visible = True;
		
		declare PosX = -41.5 + (X * 82.);
		declare PosY = Y * -23.;
		
		if (Count == Max && Count % 2 != 0) {
			PosX = 0.;
		}
		
		Control.RelativePosition.X = PosX;
		Control.RelativePosition.Y = PosY;
		
		X += 1;
		if (Count % 2 == 0) {
			Y += 1;
			X = 0;
		}
	}
	
	UpdatePager(0);
}

main() {
	declare Frame_Global <=> (Page.GetFirstChild("Frame_Global") as CMlFrame);
	
	declare netread Integer Net_Matchmaking_FormatUpdate for Teams[0];
	declare netread Integer[] Net_Matchmaking_Format for Teams[0];
	declare netread Integer Net_Lobby_AlliesLoginsUpdate for UI;
	
	declare netwrite Integer Net_Lobby_RequestAllyUpdate for UI;
	declare netwrite Text Net_Lobby_RequestAlly for UI;
	
	G_PageStart = 0;
	G_PlayersMax = {{{SlotsNb}}};
	
	declare Lobby_RulesAreVisible for UI = False;
	Lobby_RulesAreVisible = False;
	
	declare PrevIsSpectatorMode = True;
	declare PrevFormatUpdate = -1;
	declare PrevAlliesLoginUpdate = -1;
		
	HideResumePlayingButton = True;
	
	while (True) {
		yield;
		if (InputPlayer == Null || !PageIsVisible) continue;
		
		if (PrevIsSpectatorMode != IsSpectatorMode) {
			PrevIsSpectatorMode = IsSpectatorMode;
			
			if (IsSpectatorMode) {
				Frame_Global.Visible = True;
			} else {
				Frame_Global.Visible = False;
			}
		}
		
		if (Frame_Global.Visible && PrevFormatUpdate != Net_Matchmaking_FormatUpdate) {
			PrevFormatUpdate = Net_Matchmaking_FormatUpdate;
			UpdateFormat(Net_Matchmaking_Format);
		}
		
		if (Frame_Global.Visible && PrevAlliesLoginUpdate != Net_Lobby_AlliesLoginsUpdate) {
			PrevAlliesLoginUpdate = Net_Lobby_AlliesLoginsUpdate;
			UpdatePager(0);
		}
		
		foreach (Event in PendingEvents) {
			if (Event.Type == CMlEvent::Type::MouseClick) {
				switch (Event.ControlId) {
					case "Button_Rules": {
						Lobby_RulesAreVisible = True;
					}
					case "Button_Ready": {
						IsSpectatorMode = False;
					}
					case "Button_Player": {
						declare Text Lobby_PlayerLogin for Event.Control;
						Net_Lobby_RequestAllyUpdate = Now;
						Net_Lobby_RequestAlly = Lobby_PlayerLogin;
					}
					case "Button_PagerNext": {
						UpdatePager(1);
					}
					case "Button_PagerPrev": {
						UpdatePager(-1);
					}
				}
			} else if (Event.Type == CMlEvent::Type::KeyPress) {
				if (Event.KeyName == "F6") {
					IsSpectatorMode = !IsSpectatorMode;
				}
			}
		}
	}
}
--></script>""";
}

// ---------------------------------- //
/** Create the players list manialink
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLPlayersList() {
	declare SizeX = 52.;
	declare SizeY = 127.;
	
	declare Background = "file://Media/Manialinks/Common/Lobbies/side-frame.png";
	declare Echelon0 = "file://Media/Manialinks/Common/Echelons/echelon0.dds";
	
	declare PlayersNb = 20;
	declare PlayersList = "";
	declare PCSizeY = 5.;
	for (I, 1, PlayersNb) {
		declare PosY = (I - 1) * -PCSizeY;
		PlayersList ^= """<frameinstance posn="0 {{{PosY}}}" hidden="1" modelid="Framemodel_PlayerCard" id="{{{I}}}" />""";
	}
	
	return """
<framemodel class="Frame_PlayerCard" id="Framemodel_PlayerCard">
	<quad posn="0 0 -1" sizen="46 {{{PCSizeY}}}" valign="center" bgcolorfocus="ccc8" scriptevents="1" id="Button_Player" />
	<quad sizen="2 {{{PCSizeY}}}" valign="center" bgcolor="c00" opacity="0.8" id="Quad_Status" />
	<quad posn="3 0" sizen="{{{PCSizeY}}} {{{PCSizeY}}}" scale="0.9" valign="center" id="Quad_CountryFlag" />
	<label posn="8 0" sizen="34 4" valign="center2" textsize="1" textemboss="1" id="Label_Name" />
	<frame posn="{{{SizeX-8.5}}} {{{PCSizeY/2.}}} 1" scale="0.29">
		<quad sizen="14.1551 17.6938" halign="center" image="{{{Echelon0}}}" id="Quad_Echelon" />
		<label posn="0 -10" sizen="10 10" halign="center" valign="center" style="TextRaceMessageBig" text="0" id="Label_Echelon" />
	</frame>
</framemodel>
<frame posn="164 0 10" id="Frame_Global">
	<quad posn="0 0 -1" sizen="{{{SizeX}}} {{{SizeY}}}" halign="right" valign="center" image="{{{Background}}}" />
	<frame posn="{{{-SizeX/2.-1.}}} {{{SizeY/2.}}}">
		<frame id="Frame_Title">
			<label posn="0 -4.5" sizen="{{{SizeX-8}}} 4" halign="center" style="TextRaceMessage" textopacity="0.9" text="{{{_("Players")}}}" />
			<label posn="0 -13" sizen="{{{SizeX-8}}} 4" halign="center" valign="bottom" style="TextTips" textsize="1" textopacity="0.75" text="{{{_("Click on a player to set them as ally.")}}}" />
		</frame>
		<frame posn="{{{-SizeX/2.+3.2}}} -18 2" id="Frame_PlayersList">
			{{{PlayersList}}}
		</frame>
		<frame posn="0 -119.2" hidden="1" id="Frame_Pager">
			<quad posn="-5 0" sizen="9 9" halign="right" valign="center" style="Icons64x64_1" substyle="ArrowPrev" scriptevents="1" id="Button_PagerPrev" />
			<quad posn="5 0" sizen="9 9" valign="center" style="Icons64x64_1" substyle="ArrowNext" scriptevents="1" id="Button_PagerNext" />
			<label sizen="10 0" halign="center" valign="center2" id="Label_Pager" />
		</frame>
	</frame>
</frame>
<script><!--
#Include "TextLib" as TL

declare Integer G_PageStart;

Integer GetEchelon(CUser::EEchelon _Echelon) {
	switch (_Echelon) {
		case CUser::EEchelon::Bronze1	: return 1;
		case CUser::EEchelon::Bronze2	: return 2;
		case CUser::EEchelon::Bronze3	: return 3;
		case CUser::EEchelon::Silver1	: return 4;
		case CUser::EEchelon::Silver2	: return 5;
		case CUser::EEchelon::Silver3	: return 6;
		case CUser::EEchelon::Gold1		: return 7;
		case CUser::EEchelon::Gold2		: return 8;
		case CUser::EEchelon::Gold3		: return 9;
	}
	
	return 0;
}

Text GetEchelonPath(CUser::EEchelon _Echelon) {
	return "file://Media/Manialinks/Common/Echelons/echelon"^GetEchelon(_Echelon)^".dds";
}

Void UpdatePlayerCard(CMlFrame _Frame, CPlayer _Player) {
	if (_Frame == Null || _Player == Null) return;
	
	declare Button_Player 		<=> (_Frame.GetFirstChild("Button_Player")		as CMlQuad);
	declare Quad_Status			<=> (_Frame.GetFirstChild("Quad_Status")		as CMlQuad);
	declare Quad_CountryFlag	<=> (_Frame.GetFirstChild("Quad_CountryFlag")	as CMlQuad);
	declare Label_Name			<=> (_Frame.GetFirstChild("Label_Name")			as CMlLabel);
	declare Quad_Echelon		<=> (_Frame.GetFirstChild("Quad_Echelon")		as CMlQuad);
	declare Label_Echelon		<=> (_Frame.GetFirstChild("Label_Echelon")		as CMlLabel);
	
	if (Button_Player != Null) {
		declare netread Integer[Text] Net_Lobby_AlliesLogins for UI;
		if (Net_Lobby_AlliesLogins.count > 0 && _Player.Login == InputPlayer.Login) {
			Button_Player.BgColor = <0.15, 0.3, 0.15>;
			Button_Player.Opacity = 0.4;
		} else if (Net_Lobby_AlliesLogins.existskey(_Player.Login) && Net_Lobby_AlliesLogins[_Player.Login] == {{{C_AllyStatus_Validated}}}) {
			Button_Player.BgColor = <0.15, 0.3, 0.15>;
			Button_Player.Opacity = 0.4;
		} else if (Net_Lobby_AlliesLogins.existskey(_Player.Login) && Net_Lobby_AlliesLogins[_Player.Login] == {{{C_AllyStatus_Sent}}}) {
			Button_Player.BgColor = <0.3, 0.15, 0.>;
			Button_Player.Opacity = 0.4;
		} else {
			Button_Player.BgColor = <0.2, 0.2, 0.2>;
			Button_Player.Opacity = 0.5;
		}
		
		declare Text Lobby_PlayerLogin for Button_Player;
		Lobby_PlayerLogin = _Player.User.Login;
	}
	if (Quad_Status != Null) {
		declare netread Boolean Net_Lobby_AlliesAreReady for _Player;
		if (_Player.User.RequestsSpectate) Quad_Status.BgColor = <0.8, 0., 0.>;
		else if (!Net_Lobby_AlliesAreReady) Quad_Status.BgColor = <1., 0.5, 0.>;
		else Quad_Status.BgColor = <0., 0.8, 0.>;
	}
	if (Quad_CountryFlag != Null) Quad_CountryFlag.ImageUrl = _Player.User.CountryFlagUrl;
	if (Label_Name != Null) Label_Name.Value = _Player.User.Name;
	if (Quad_Echelon != Null) Quad_Echelon.ImageUrl = GetEchelonPath(_Player.User.Echelon);
	if (Label_Echelon != Null) Label_Echelon.Value = TL::ToText(GetEchelon(_Player.User.Echelon));
}

Void UpdatePlayersList() {
	declare Integer[CSmPlayer] ToSort;
	declare Lobby_ReadyNb for UI = 0;
	Lobby_ReadyNb = 0;
	foreach (Player in Players) {
		declare netread Boolean Net_Lobby_AlliesAreReady for Player;
		declare netread Integer[Text] Net_Lobby_AlliesLogins for UI;
		
		if (Player.Login == InputPlayer.Login) {
			ToSort[Player] = 0;
		} else if (Net_Lobby_AlliesLogins.existskey(Player.Login)) {
			if (Net_Lobby_AlliesLogins[Player.Login] == {{{C_AllyStatus_Validated}}}) ToSort[Player] = 1;
			else ToSort[Player] = 2;
		} else if (Player.User.RequestsSpectate) {
			ToSort[Player] = 5;
		} else if (!Net_Lobby_AlliesAreReady) {
			ToSort[Player] = 4;
		} else {
			ToSort[Player] = 3;
		}
		
		if (!Player.User.RequestsSpectate && Net_Lobby_AlliesAreReady) {
			Lobby_ReadyNb += 1;
		}
	}
	
	declare CSmPlayer[] SortedPlayers;
	ToSort = ToSort.sort();
	foreach (Player => Status in ToSort) {
		SortedPlayers.add(Player);
	}
	
	declare Frame_PlayersList <=> (Page.GetFirstChild("Frame_PlayersList") as CMlFrame);
	Page.GetClassChildren("Frame_PlayerCard", Frame_PlayersList, False);
	foreach (Control in Page.GetClassChildren_Result) {
		declare Frame_PlayerCard <=> (Control as CMlFrame);
		declare Count = G_PageStart + TL::ToInteger(Frame_PlayerCard.ControlId);
		
		if (SortedPlayers.existskey(Count-1)) {
			Frame_PlayerCard.Visible = True;
			UpdatePlayerCard(Frame_PlayerCard, SortedPlayers[Count-1]);
		} else {
			Frame_PlayerCard.Visible = False;
		}
	}
}

Void UpdatePager(Integer _Shift) {
	declare NewPageStart = G_PageStart + (_Shift * {{{PlayersNb}}});
	if (NewPageStart < 0) NewPageStart = 0;
	else if (NewPageStart > Players.count - 1) NewPageStart = G_PageStart;
	G_PageStart = NewPageStart;
	if (G_PageStart > Players.count) G_PageStart = Players.count - 1;
	
	declare Frame_Pager <=> (Page.GetFirstChild("Frame_Pager") as CMlFrame);
	if (Players.count > {{{PlayersNb}}}) {
		Frame_Pager.Visible = True;
	} else {
		Frame_Pager.Visible = False;
		G_PageStart = 0;
	}
	
	declare Button_PagerNext <=> (Frame_Pager.GetFirstChild("Button_PagerNext") as CMlQuad);
	declare Button_PagerPrev <=> (Frame_Pager.GetFirstChild("Button_PagerPrev") as CMlQuad);
	if (G_PageStart <= 0) Button_PagerPrev.Substyle = "ArrowDisabled";
	else Button_PagerPrev.Substyle = "ArrowPrev";
	if (G_PageStart + {{{PlayersNb}}} >= Players.count) Button_PagerNext.Substyle = "ArrowDisabled";
	else Button_PagerNext.Substyle = "ArrowNext";
	
	UpdatePlayersList();
}

main() {
	declare netread Integer Net_Lobby_PlayersListUpdate for Teams[0];
	declare netwrite Integer Net_Lobby_RequestAllyUpdate for UI;
	declare netwrite Text Net_Lobby_RequestAlly for UI;
	
	declare Lobby_ReadyNb for UI = 0;
	Lobby_ReadyNb = 0;
	
	declare PrevPlayersListUpdate = -1;
	
	declare NextUpdate = 0;
	
	G_PageStart = 0;
	
	while (True) {
		yield;
		if (InputPlayer == Null || !PageIsVisible) continue;
		
		if (PrevPlayersListUpdate != Net_Lobby_PlayersListUpdate) {
			PrevPlayersListUpdate = Net_Lobby_PlayersListUpdate;
			UpdatePager(0);
		}
		
		if (Now >= NextUpdate) {
			NextUpdate = Now + 1000;
			foreach (Player in Players) {
				declare PrevRequestsSpectate for Player = False;
				declare PrevAlliesAreReady for Player = False;
				declare netread Boolean Net_Lobby_AlliesAreReady for Player;
				if (PrevRequestsSpectate != Player.User.RequestsSpectate || PrevAlliesAreReady != Net_Lobby_AlliesAreReady) {
					PrevRequestsSpectate = Player.User.RequestsSpectate;
					PrevAlliesAreReady = Net_Lobby_AlliesAreReady;
					UpdatePager(0);
				}
			}
		}
		
		foreach (Event in PendingEvents) {
			if (Event.Type == CMlEvent::Type::MouseClick) {
				if (Event.ControlId == "Button_Player") {
					declare Text Lobby_PlayerLogin for Event.Control;
					Net_Lobby_RequestAllyUpdate = Now;
					Net_Lobby_RequestAlly = Lobby_PlayerLogin;
				} else if (Event.ControlId == "Button_PagerNext") {
					UpdatePager(1);
				} else if (Event.ControlId == "Button_PagerPrev") {
					UpdatePager(-1);
				}
			}
		}
	}
}
--></script>""";
}

// ---------------------------------- //
/** Create the masters list manialink
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLMastersList() {
	declare SizeX = 52.;
	declare SizeY = 127.;
	
	declare Background = "file://Media/Manialinks/Common/Lobbies/side-frame.png";
	declare Echelon0 = "file://Media/Manialinks/Common/Echelons/echelon0.dds";
	
	declare PlayersNb = 20;
	declare PlayersList = "";
	declare PCSizeY = 5.;
	for (I, 1, PlayersNb) {
		declare PosY = (I - 1) * -PCSizeY;
		PlayersList ^= """<frameinstance posn="0 {{{PosY}}}" hidden="1" modelid="Framemodel_PlayerCard" id="{{{I}}}" />""";
	}
	
	return """
<framemodel class="Frame_PlayerCard" id="Framemodel_PlayerCard">
	<quad posn="0 0 -1" sizen="45 {{{PCSizeY}}}" valign="center" bgcolor="3337" bgcolorfocus="9997" scriptevents="1" id="Button_Player" />
	<quad sizen="2 {{{PCSizeY}}}" valign="center" bgcolor="000" opacity="0.8" id="Quad_Status" />
	<quad posn="3 0" sizen="{{{PCSizeY}}} {{{PCSizeY}}}" scale="0.9" valign="center" id="Quad_CountryFlag" />
	<label posn="8 0" sizen="32 4" valign="center2" textsize="1" textemboss="1" id="Label_Name" />
	<frame posn="{{{SizeX-9.2}}} {{{PCSizeY/2.}}} 1" scale="0.29">
		<quad sizen="14.1551 17.6938" halign="center" image="{{{Echelon0}}}" id="Quad_Echelon" />
		<label posn="0 -10" sizen="10 10" halign="center" valign="center" style="TextRaceMessageBig" text="0" id="Label_Echelon" />
	</frame>
</framemodel>
<frame posn="-165 0 10" id="Frame_Global">
	<quad posn="0 0 -1" sizen="{{{SizeX}}} {{{SizeY}}}" valign="center" image="{{{Background}}}" />
	<frame posn="{{{SizeX/2.+1.}}} {{{SizeY/2.}}}">
		<frame id="Frame_Title">
			<label posn="0 -6" sizen="{{{SizeX-8}}} 4" halign="center" style="TextRaceMessage" textopacity="0.9" text="Masters" />
		</frame>
		<frame posn="{{{-SizeX/2.+4.}}} -18 2" id="Frame_PlayersList">
			{{{PlayersList}}}
		</frame>
		<frame posn="0 -119.2" hidden="1" id="Frame_Pager">
			<quad posn="-5 0" sizen="9 9" halign="right" valign="center" style="Icons64x64_1" substyle="ArrowPrev" scriptevents="1" id="Button_PagerPrev" />
			<quad posn="5 0" sizen="9 9" valign="center" style="Icons64x64_1" substyle="ArrowNext" scriptevents="1" id="Button_PagerNext" />
			<label sizen="10 0" halign="center" valign="center2" id="Label_Pager" />
		</frame>
	</frame>
</frame>
<script><!--
Text GetEchelonPath(Text _Echelon) {
	return "file://Media/Manialinks/Common/Echelons/echelon"^_Echelon^".dds";
}

Void UpdatePlayerCard(Integer _Slot, CMlFrame _Frame) {
	declare netread Text[Integer][] Net_Lobby_Masters for Teams[0];
	
	if (_Frame == Null || !Net_Lobby_Masters.existskey(_Slot)) return;
	
	declare Quad_CountryFlag<=> (_Frame.GetFirstChild("Quad_CountryFlag")	as CMlQuad);
	declare Label_Name		<=> (_Frame.GetFirstChild("Label_Name")			as CMlLabel);
	declare Quad_Echelon	<=> (_Frame.GetFirstChild("Quad_Echelon")		as CMlQuad);
	declare Label_Echelon	<=> (_Frame.GetFirstChild("Label_Echelon")		as CMlLabel);
	
	if (Quad_CountryFlag != Null) Quad_CountryFlag.ImageUrl = Net_Lobby_Masters[_Slot][{{{C_Master_Country}}}];
	if (Label_Name != Null) Label_Name.Value = Net_Lobby_Masters[_Slot][{{{C_Master_Name}}}];
	if (Quad_Echelon != Null) Quad_Echelon.ImageUrl = GetEchelonPath(Net_Lobby_Masters[_Slot][{{{C_Master_Echelon}}}]);
	if (Label_Echelon != Null) Label_Echelon.Value = Net_Lobby_Masters[_Slot][{{{C_Master_Echelon}}}];
	
	_Frame.Visible = True;
}

Void UpdateMastersList() {
	declare Frame_PlayersList <=> (Page.GetFirstChild("Frame_PlayersList") as CMlFrame);
	
	foreach (Key => Control in Frame_PlayersList.Controls) {
		Control.Visible = False;
		UpdatePlayerCard(Key, (Control as CMlFrame));
	}
}

main() {
	declare netread Integer Net_Lobby_MastersUpdate for Teams[0];
	
	declare PrevMastersUpdate = -1;
	
	while (True) {
		yield;
		if (!PageIsVisible || InputPlayer == Null) continue;
		
		if (PrevMastersUpdate != Net_Lobby_MastersUpdate) {
			PrevMastersUpdate = Net_Lobby_MastersUpdate;
			UpdateMastersList();
		}
	}
}
--></script>""";
}

// ---------------------------------- //
/** Create the header manialink
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLHeader() {
	declare SizeX = 91.;
	declare SizeY = 27.;
	
	declare Background = "file://Media/Manialinks/Common/Lobbies/header.png";
	
	return """
<frame posn="0 86" id="Frame_Global">
	<quad posn="0 0 -1" sizen="{{{SizeX}}} {{{SizeY}}}" halign="center" image="{{{Background}}}" />
	<label posn="0 -4" sizen="{{{SizeX-7}}} {{{SizeY}}}" halign="center" style="TextRaceMessage" textsize="3" id="Label_ServerName" />
	<label posn="{{{SizeX/2.-5.}}} -16" sizen="{{{SizeX/3.}}} 4" halign="right" valign="center" style="TextRaceMessage" textsize="2" opacity="0.75" id="Label_WaitingTime" />
	<label posn="{{{SizeX/2.-5.}}} -18" sizen="{{{SizeX/2.}}} 4" halign="right" valign="top" style="TextRaceMessage" scale="0.5" opacity="0.5" text="{{{_("Average waiting time")}}}" />
	<label posn="{{{-SizeX/2.+5.}}} -16" sizen="{{{SizeX/3.}}} 4" valign="center" style="TextRaceMessage" textsize="2" opacity="0.75" id="Label_PlayersNb" />
	<label posn="{{{-SizeX/2.+5.}}} -18" sizen="{{{SizeX/2.}}} 4" valign="top" style="TextRaceMessage" scale="0.5" opacity="0.5" id="Label_ReadyNb" />
	<label posn="0 -27" halign="center" style="TextRaceMessageBig" textsize="3" id="Label_Message" />
</frame>
<script><!--
#Include "TextLib" as TL

main() {
	declare Label_ServerName	<=> (Page.GetFirstChild("Label_ServerName")		as CMlLabel);
	declare Label_PlayersNb		<=> (Page.GetFirstChild("Label_PlayersNb")		as CMlLabel);
	declare Label_ReadyNb		<=> (Page.GetFirstChild("Label_ReadyNb")		as CMlLabel);
	declare Label_WaitingTime	<=> (Page.GetFirstChild("Label_WaitingTime")	as CMlLabel);
	declare Label_Message		<=> (Page.GetFirstChild("Label_Message")		as CMlLabel);
	
	declare netread Integer Net_Lobby_PlayersNb for Teams[0];
	declare netread Integer Net_Lobby_WaitingTime for Teams[0];
	
	declare Lobby_ReadyNb for UI = 0;
	
	declare PrevServerName = "";
	declare PrevPlayersNb = -1;
	declare PrevReadyNb = -1;
	declare PrevWaitingTime = -2;
	declare PrevAlliesAreReady = True;
	declare PrevMessage = "";
	declare PrevIsSpectatorMode = False;
	
	while (True) {
		sleep(100);
		if (InputPlayer == Null || !PageIsVisible) continue;
		
		if (PrevServerName != CurrentServerName) {
			PrevServerName = CurrentServerName;
			Label_ServerName.Value = CurrentServerName;
		}
		
		if (PrevPlayersNb != Net_Lobby_PlayersNb) {
			PrevPlayersNb = Net_Lobby_PlayersNb;
			Label_PlayersNb.Value = TL::Compose("%1 playing", TL::ToText(Net_Lobby_PlayersNb));
		}
		
		if (PrevReadyNb != Lobby_ReadyNb) {
			PrevReadyNb = Lobby_ReadyNb;
			Label_ReadyNb.Value = TL::Compose("%1 ready", TL::ToText(Lobby_ReadyNb));
		}
		
		if (PrevWaitingTime != Net_Lobby_WaitingTime) {
			PrevWaitingTime = Net_Lobby_WaitingTime;
			if (Net_Lobby_WaitingTime < 0) Label_WaitingTime.Value = "- min";
			else Label_WaitingTime.Value = TL::Compose("%1 min", TL::ToText(Net_Lobby_WaitingTime));
		}
		
		if (PrevMessage != UI.StatusMessage || PrevIsSpectatorMode != IsSpectatorMode) {
			PrevMessage = UI.StatusMessage;
			PrevIsSpectatorMode = IsSpectatorMode;
			if (UI.StatusMessage != "" || IsSpectatorMode) Label_Message.Visible = False;
			else Label_Message.Visible = True;
		}
		
		declare netread Boolean Net_Lobby_AlliesAreReady for InputPlayer;
		if (PrevAlliesAreReady != Net_Lobby_AlliesAreReady) {
			PrevAlliesAreReady = Net_Lobby_AlliesAreReady;
			if (Net_Lobby_AlliesAreReady) Label_Message.Value = "";
			else Label_Message.Value = "{{{_("Waiting for your allies to be ready.")}}}";
		}
	}
}
--></script>""";
}

// ---------------------------------- //
/** Create the send to server manialink
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLSendToServer() {
	return """
<script><!--
declare netread Integer Net_Lobby_JoinLinkUpdate for UI;
declare netread Text Net_Lobby_JoinLink for UI;

declare PrevUpdate = Net_Lobby_JoinLinkUpdate;

while (True) {
	yield;
	if (InputPlayer == Null || !PageIsVisible) continue;
	
	if (PrevUpdate != Net_Lobby_JoinLinkUpdate) {
		PrevUpdate = Net_Lobby_JoinLinkUpdate;
		
		if (Net_Lobby_JoinLink != "") {
			OpenLink(Net_Lobby_JoinLink, CMlScript::LinkType::ManialinkBrowser);
		}
	}
}
--></script>""";
}

// ---------------------------------- //
/** Create the send to server manialink
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLRules() {
	declare ManialinkRules = "";
	---ManialinkRules---
	
	declare ML = "";
	if (ManialinkRules != "") {
		ML ^= """
<frame posn="0 0 30" hidden="1" id="Frame_Global">
	{{{ManialinkRules}}}
</frame>
<script><!--
main() {
	declare Frame_Global <=> (Page.GetFirstChild("Frame_Global") as CMlFrame);
	
	declare Lobby_RulesAreVisible for UI = False;
	Lobby_RulesAreVisible = False;
	
	declare PrevRulesAreVisible = False;
	
	while (True) {
		yield;
		if (InputPlayer == Null || !PageIsVisible) continue;
		
		if (PrevRulesAreVisible != Lobby_RulesAreVisible) {
			PrevRulesAreVisible = Lobby_RulesAreVisible;
			
			Frame_Global.Visible = Lobby_RulesAreVisible;
		}
		
		foreach (Event in PendingEvents) {
			if (Event.Type == CMlEvent::Type::MouseClick) {
				if (Event.ControlId == "Button_Back") {
					Lobby_RulesAreVisible = False;
				}
			}
		}
	}
}
--></script>""";
	}
	
	return ML;
}

// ---------------------------------- //
/** Create the starting match manialink
 *
 *	@return		The manialink
 */
Text Private_MM_GetMLStartingMatch() {
	declare ReqPlayersNb = 0;
	foreach (PlayersNb in G_Matchmaking_Format) ReqPlayersNb += PlayersNb;
	
	declare ImgPlayer = "file://Media/Manialinks/Shootmania/Common/DefendersLeft.dds";
	declare ImgSize = 8.;
	declare XMargin = 1.;
	
	declare PlayersList = "";
	for(I, 0, ReqPlayersNb-1) {
		declare PosX = (-I*(ImgSize + XMargin)) - (ImgSize/2.);
		declare PosY = -ImgSize/2.;
		
		PlayersList ^= """<quad posn="{{{PosX}}} {{{PosY}}}" sizen="{{{ImgSize}}} {{{ImgSize}}}" halign="center" valign="center" image="{{{ImgPlayer}}}" colorize="777" scale="0.5" class="Quad_Player" id="{{{I}}}" />""";
	}
	
	return """
<frame posn="155 -79" id="Frame_Waiting">
	<label halign="right" valign="bottom" textsize="3" textemboss="1" id="Label_Waiting" />
	<frame>
		{{{PlayersList}}}
	</frame>
</frame>
<frame posn="155 -86" hidden="1" id="Frame_Ready">
	<label halign="right" valign="bottom" textsize="3" textemboss="1" text="{{{_("The match will begin shortly ...")}}}" />
</frame>
<script><!--
#Include "TextLib" as TL

main() {
	declare Label_Waiting	<=> (Page.GetFirstChild("Label_Waiting")	as CMlLabel);
	declare Frame_Waiting	<=> (Page.GetFirstChild("Frame_Waiting")	as CMlFrame);
	declare Frame_Ready		<=> (Page.GetFirstChild("Frame_Ready")		as CMlFrame);
	
	declare CMlQuad[Integer] Quads_Player;
	Page.GetClassChildren("Quad_Player", Frame_Waiting, True);
	foreach (Control in Page.GetClassChildren_Result) {
		declare Key = TL::ToInteger(Control.ControlId);
		Quads_Player[Key] = (Control as CMlQuad);
	}
	
	Label_Waiting.SetText(_("Waiting for players"));
	
	declare netread Integer Net_MM_ReadyPlayersNb for Teams[0];
	declare netread Integer Net_MM_ReadyPlayersMax for Teams[0];
	declare PrevReadyPlayersNb = -1;
	
	while (True) {
		yield;
		if (InputPlayer == Null || !PageIsVisible) continue;
		
		if (PrevReadyPlayersNb != Net_MM_ReadyPlayersNb) {
			PrevReadyPlayersNb = Net_MM_ReadyPlayersNb;
			
			foreach (Key => Quad_Player in Quads_Player) {
				if (Key <= Net_MM_ReadyPlayersNb - 1) {
					Quad_Player.Colorize = <1., 1., 1.>;
					Quad_Player.RelativeScale = 1.;
				} else {
					Quad_Player.Colorize = <0.5, 0.5, 0.5>;
					Quad_Player.RelativeScale = 0.5;
				}
			}
			
			if (Net_MM_ReadyPlayersNb >= Net_MM_ReadyPlayersMax) {
				PlayUiSound(::EUISound::Custom4, 1, 0.75);
			} else {
				PlayUiSound(::EUISound::Custom4, 0, 0.75);
			}
		}
		
		if (!Frame_Waiting.Visible && Net_MM_ReadyPlayersNb < Net_MM_ReadyPlayersMax) {
			Frame_Waiting.Show();
			Frame_Ready.Hide();
		} else if (!Frame_Ready.Visible && Net_MM_ReadyPlayersNb >= Net_MM_ReadyPlayersMax) {
			Frame_Waiting.Hide();
			Frame_Ready.Show();
		}
	}
}
--></script>
""";
}

// ---------------------------------- //
/** Create the versus manialink
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLVersus() {
	declare Background = "file://Media/Manialinks/Common/Lobbies/versus-bg.dds";
	declare Background_PlayerCard = "file://Media/Manialinks/Common/Lobbies/PlayerCardBg.dds";
	declare ButtonQuitOn = "file://Media/Manialinks/Common/Lobbies/small-button-RED-ON.dds";
	declare ButtonQuitOff = "file://Media/Manialinks/Common/Lobbies/small-button-RED.dds";
	declare Echelon0 = "file://Media/Manialinks/Common/Echelons/echelon0.dds";
	
	declare SlotsNb = 3;
	declare PlayersList = "";
	for (I, 0, SlotsNb-1) {
		declare PosY = -18. * I;
		PlayersList ^= """<frameinstance posn="0 {{{PosY}}}" scale="0.7" modelid="Framemodel_PlayerCard" id="{{{I}}}" />""";
	}
	
	return """
<framemodel id="Framemodel_PlayerCard">
	<frame posn="-40 10" hidden="1" id="Frame_PlayerCard">
		<quad sizen="80 20 -1" image="{{{Background_PlayerCard}}}" />
		<quad posn="0.75 -10 1" sizen="18.5 18.5" valign="center" bgcolor="aaa" id="Quad_Avatar" />
		<label posn="22 -4" sizen="38 4" style="TextRaceMessage" textsize="3.5" id="Label_Name" />
		<label posn="27 -15" sizen="30 4" valign="center2" style="TextRaceMessage" textsize="1" id="Label_Rank" />
		<quad posn="22 -15" sizen="4 4" valign="center" id="Quad_CountryFlag" />
		<frame posn="72 0 1" scale="1.13">
			<quad sizen="14.1551 17.6938" halign="center" image="{{{Echelon0}}}" id="Quad_Echelon" />
			<label posn="0 -3.6" sizen="14 0" halign="center" style="TextRaceMessage" textsize="0.5" text="Echelon" />
			<label posn="0 -10.6" sizen="10 10" halign="center" valign="center" style="TextRaceMessageBig" text="0" id="Label_Echelon" />
		</frame>
	</frame>
</framemodel>
<frame posn="0 -12" hidden="1" id="Frame_Global">
	<frame posn="0 0 -1">
		<quad sizen="190 190" halign="center" valign="center" image="{{{Background}}}" />
	</frame>
	<frame>
		<label posn="0 40" sizen="200 20" halign="center" valign="center2" style="TextRaceMessageBig" textsize="2" id="Label_Info" />
		<label posn="0 40" sizen="200 20" halign="center" valign="center2" style="TextRaceMessageBig" textsize="2" text="{{{_("You are being transferred. Please wait.")}}}" id="Label_Transfert" />
		<frame posn="-45 25" id="Frame_Clan1">
			{{{PlayersList}}}
		</frame>
		<frame posn="45 25" id="Frame_Clan2">
			{{{PlayersList}}}
		</frame>
		<frame posn="0 6" hidden="1" id="Frame_Pager">
			<quad posn="-1 0" sizen="9 9" halign="right" valign="center" style="Icons64x64_1" substyle="ArrowUp" scriptevents="1" id="Button_PagerPrev" />
			<quad posn="1 0" sizen="9 9" valign="center" style="Icons64x64_1" substyle="ArrowDown" scriptevents="1" id="Button_PagerNext" />
		</frame>
	</frame>
	<frame posn="0 -50">
		<quad sizen="35 8" scale="1.3" halign="center" valign="center" image="{{{ButtonQuitOff}}}" imagefocus="{{{ButtonQuitOn}}}" action="maniaplanet:togglespec" />
		<label sizen="35 8" scale="0.95" halign="center" valign="center2" style="TextRaceMessageBig" opacity="0.8" textsize="2" text="{{{_("F6 to cancel")}}}" id="Label_Quit" />
	</frame>
</frame>
<script><!--
#Include "TextLib" as TL

declare Integer G_PageStart;

CUser GetUser(Text _Login) {
	foreach (Player in Players) {
		if (Player.Login == _Login) return Player.User;
	}
	
	return Null;
}

Integer GetEchelon(CUser::EEchelon _Echelon) {
	switch (_Echelon) {
		case CUser::EEchelon::Bronze1	: return 1;
		case CUser::EEchelon::Bronze2	: return 2;
		case CUser::EEchelon::Bronze3	: return 3;
		case CUser::EEchelon::Silver1	: return 4;
		case CUser::EEchelon::Silver2	: return 5;
		case CUser::EEchelon::Silver3	: return 6;
		case CUser::EEchelon::Gold1		: return 7;
		case CUser::EEchelon::Gold2		: return 8;
		case CUser::EEchelon::Gold3		: return 9;
	}
	
	return 0;
}

Text GetEchelonPath(CUser::EEchelon _Echelon) {
	return "file://Media/Manialinks/Common/Echelons/echelon"^GetEchelon(_Echelon)^".dds";
}

Void UpdatePlayerSlot(CMlFrame _Frame, CUser _User) {
	if (_User == Null) {
		_Frame.Visible = False;
		return;
	} else {
		_Frame.Visible = True;
	}
	
	declare Quad_Avatar			<=> (_Frame.GetFirstChild("Quad_Avatar")		as CMlQuad);
	declare Label_Name			<=> (_Frame.GetFirstChild("Label_Name")			as CMlLabel);
	declare Label_Rank			<=> (_Frame.GetFirstChild("Label_Rank")			as CMlLabel);
	declare Quad_CountryFlag	<=> (_Frame.GetFirstChild("Quad_CountryFlag")	as CMlQuad);
	declare Quad_Echelon		<=> (_Frame.GetFirstChild("Quad_Echelon")		as CMlQuad);
	declare Label_Echelon		<=> (_Frame.GetFirstChild("Label_Echelon")		as CMlLabel);
	
	if (Quad_Avatar != Null)		Quad_Avatar.ImageUrl = "file://Avatars/"^_User.Login^"/Default";
	if (Label_Name != Null)			Label_Name.Value = _User.Name;
	if (Quad_CountryFlag != Null)	Quad_CountryFlag.ImageUrl = _User.CountryFlagUrl;
	if (Quad_Echelon != Null)		Quad_Echelon.ImageUrl = GetEchelonPath(_User.Echelon);
	if (Label_Echelon != Null)		Label_Echelon.Value = TL::ToText(GetEchelon(_User.Echelon));
	if (Label_Rank != Null) {
		declare Zone = _("Other");
		declare ZoneArray = TL::Split("|", _User.LadderZoneName);
		if (ZoneArray.existskey(2)) Zone = ZoneArray[2];
		if (_User.LadderRank > 0) Label_Rank.Value = TL::Compose("%1: %2", Zone, TL::ToText(_User.LadderRank));
		else Label_Rank.Value = TL::Compose("%1: %2", Zone, _("Not ranked"));
	}
}

Void UpdatePlayersList() {
	declare netread Integer[Text] Net_Lobby_VersusPlayers for UI;
	
	declare ClansUsers = Real[CUser][Integer];
	foreach (Login => Clan in Net_Lobby_VersusPlayers) {
		if (!ClansUsers.existskey(Clan)) ClansUsers[Clan] = Real[CUser];
		declare CUser User;
		declare Real LadderPoints;
		
		User <=> GetUser(Login);
		if (User != Null) LadderPoints = User.LadderPoints;
		
		// @Debug
		if (User.IsFakeUser) LadderPoints = GetEchelon(User.Echelon) * 10000.;
		
		ClansUsers[Clan][User] = -LadderPoints;
	}
	
	declare Frames_Clan = [
		0 => (Page.GetFirstChild("Frame_Clan1") as CMlFrame), 
		1 => (Page.GetFirstChild("Frame_Clan2") as CMlFrame)
	];
	
	for (I, 0, 1) {
		if (!ClansUsers.existskey(I+1)) continue;
		
		declare ClansUsersSorted = ClansUsers[I+1].sort();
		
		declare ClanUsers = CUser[];
		foreach (User => LadderPoints in ClansUsersSorted) {
			ClanUsers.add(User);
		}
		
		foreach (Control in Frames_Clan[I].Controls) {
			declare Frame_PlayerCard <=> ((Control as CMlFrame).GetFirstChild("Frame_PlayerCard") as CMlFrame);
			declare Slot = G_PageStart + TL::ToInteger(Control.ControlId);
			
			if (ClanUsers.existskey(Slot)) UpdatePlayerSlot(Frame_PlayerCard, ClanUsers[Slot]);
			else UpdatePlayerSlot(Frame_PlayerCard, Null);
		}
	}
}

Void UpdatePager(Integer _Shift) {
	declare netread Integer[Text] Net_Lobby_VersusPlayers for UI;
	declare MaxPlayers = Integer[Integer];
	declare Max = 0;
	foreach (Login => Clan in Net_Lobby_VersusPlayers) {
		if (!MaxPlayers.existskey(Clan)) MaxPlayers[Clan] = 0;
		MaxPlayers[Clan] += 1;
		if (MaxPlayers[Clan] > Max) Max = MaxPlayers[Clan];
	}
	
	declare Frame_Pager <=> (Page.GetFirstChild("Frame_Pager") as CMlFrame);
	if (Max > {{{SlotsNb}}}) {
		Frame_Pager.Visible = True;
	} else if (Max <= {{{SlotsNb}}}) {
		Frame_Pager.Visible = False;
		G_PageStart = 0;
	}
	
	declare NewPageStart = G_PageStart + (_Shift * {{{SlotsNb}}});
	if (NewPageStart < 0) NewPageStart = 0;
	else if (NewPageStart > Max - 1) NewPageStart = G_PageStart;
	G_PageStart = NewPageStart;
	if (G_PageStart > Max) G_PageStart = Max - 1;
	
	declare Button_PagerNext <=> (Frame_Pager.GetFirstChild("Button_PagerNext") as CMlQuad);
	declare Button_PagerPrev <=> (Frame_Pager.GetFirstChild("Button_PagerPrev") as CMlQuad);
	if (G_PageStart <= 0) Button_PagerPrev.Substyle = "ArrowDisabled";
	else Button_PagerPrev.Substyle = "ArrowUp";
	if (G_PageStart + {{{SlotsNb}}} >= Max) Button_PagerNext.Substyle = "ArrowDisabled";
	else Button_PagerNext.Substyle = "ArrowDown";
	
	UpdatePlayersList();
}

Void UpdateFormat() {
	declare netread Integer[] Net_Matchmaking_Format for Teams[0];
	
	declare Frames_Clan = [
		0 => (Page.GetFirstChild("Frame_Clan1") as CMlFrame), 
		1 => (Page.GetFirstChild("Frame_Clan2") as CMlFrame)
	];
	
	if (Net_Matchmaking_Format.count == 1) {
	
	} else if (Net_Matchmaking_Format.count == 2) {
		Frames_Clan[0].RelativePosition.X = -45.;
		Frames_Clan[1].RelativePosition.X = 45.;
		for (I, 0, 1) {
			switch (Net_Matchmaking_Format[I]) {
				case 1	: {
					Frames_Clan[I].RelativePosition.Y = 25. - 18.;
				}
				case 2	: {
					Frames_Clan[I].RelativePosition.Y = 25. - 9.;
				}
				default	: {
					Frames_Clan[I].RelativePosition.Y = 25.;
				}
			}
			
			foreach (Control in Frames_Clan[I].Controls) {
				declare Frame_PlayerCard <=> ((Control as CMlFrame).GetFirstChild("Frame_PlayerCard") as CMlFrame);
				if (TL::ToInteger(Control.ControlId) >= Net_Matchmaking_Format[I]) Frame_PlayerCard.Visible = False;
				else Frame_PlayerCard.Visible = True;
			}
		}
	} else {
		
	}
	
	UpdatePager(0);
}

main() {
	declare Frame_Global <=> (Page.GetFirstChild("Frame_Global") as CMlFrame);
	
	declare netread Integer Net_Matchmaking_FormatUpdate for Teams[0];
	declare netread Boolean Net_Lobby_ShowVersusML for UI;
	declare netread Integer Net_Lobby_VersusPlayersUpdate for UI;
	
	G_PageStart = 0;
	
	declare PrevFormatUpdate = -1;
	declare PrevShowVersusML = False;
	declare PrevVersusPlayersUpdate = -1;
	declare PrevIsSpectatorMode = False;
		
	while (True) {
		yield;
		if (!PageIsVisible || InputPlayer == Null) continue;
		
		if (PrevShowVersusML != Net_Lobby_ShowVersusML) {
			PrevShowVersusML = Net_Lobby_ShowVersusML;
			Frame_Global.Visible = Net_Lobby_ShowVersusML;
		}
		
		if (PrevIsSpectatorMode != IsSpectatorMode) {
			PrevIsSpectatorMode = IsSpectatorMode;
			if (IsSpectatorMode) {
				Frame_Global.Visible = False;
			} else {
				Frame_Global.Visible = Net_Lobby_ShowVersusML;
			}
		}
		
		if (!Frame_Global.Visible) continue;
		
		if (PrevFormatUpdate != Net_Matchmaking_FormatUpdate) {
			PrevFormatUpdate = Net_Matchmaking_FormatUpdate;
			UpdateFormat();
		}
		
		if (PrevVersusPlayersUpdate != Net_Lobby_VersusPlayersUpdate) {
			PrevVersusPlayersUpdate = Net_Lobby_VersusPlayersUpdate;
			UpdatePager(0);
		}
		
		foreach (Event in PendingEvents) {
			if (Event.Type == CMlEvent::Type::MouseClick) {
				if (Event.ControlId == "Button_PagerNext") {
					UpdatePager(1);
				} else if (Event.ControlId == "Button_PagerPrev") {
					UpdatePager(-1);
				}
			}
		}
	}
}
--></script>""";
}

// ---------------------------------- //
/** Create the substitute manialink
 *
 *	@return		The manialink
 */
Text Private_Lobby_GetMLSubstitute() {
	declare ButtonQuitOn = "file://Media/Manialinks/Common/Lobbies/small-button-RED-ON.dds";
	declare ButtonQuitOff = "file://Media/Manialinks/Common/Lobbies/small-button-RED.dds";
	
	return """
<frame posn="0 10" hidden="1" id="Frame_Global">
	<label halign="center" valign="center" style="TextRaceMessageBig" textsize="6" text="{{{_("You are being transferred as a substitute.")}}}" />
	<label posn="0 -8" halign="center" valign="center" style="TextRaceMessageBig" textsize="4" text="{{{_("Please wait.")}}}" />
	<frame posn="0 -18">
		<quad sizen="35 8" scale="1.3" halign="center" valign="center" image="{{{ButtonQuitOff}}}" imagefocus="{{{ButtonQuitOn}}}" action="maniaplanet:togglespec" />
		<label sizen="35 8" scale="0.95" halign="center" valign="center2" style="TextRaceMessageBig" opacity="0.8" textsize="2" text="{{{_("F6 to cancel")}}}" id="Label_Quit" />
	</frame>
</frame>
<script><!--
main() {
	declare Frame_Global <=> (Page.GetFirstChild("Frame_Global") as CMlFrame);
	
	declare netread Boolean Net_Lobby_ShowSubstituteML for UI;
	
	declare PrevShowSubstituteML = False;
	declare PrevIsSpectatorMode = False;
	
	while (True) {
		yield;
		if (!PageIsVisible || InputPlayer == Null) continue;
		
		if (PrevShowSubstituteML != Net_Lobby_ShowSubstituteML) {
			PrevShowSubstituteML = Net_Lobby_ShowSubstituteML;
			Frame_Global.Visible = Net_Lobby_ShowSubstituteML;
		}
		
		if (PrevIsSpectatorMode != IsSpectatorMode) {
			PrevIsSpectatorMode = IsSpectatorMode;
			if (IsSpectatorMode) {
				Frame_Global.Visible = False;
			} else {
				Frame_Global.Visible = Net_Lobby_ShowSubstituteML;
			}
		}
	}
}
--></script>""";
}

// ---------------------------------- //
/** Set the new matchmaking format on this server
 *
 *	@param	_NewFormat		The new format
 */
Void MM_SetFormat(Integer[] _NewFormat) {
	G_Matchmaking_Format = _NewFormat;
	
	declare Max = 0;
	foreach (PlayersNb in G_Matchmaking_Format) {
		if (PlayersNb > Max) Max = PlayersNb;
	}
	G_Matchmaking_MaxPlayers = Max;
	
	declare netwrite Integer Net_Matchmaking_FormatUpdate for Teams[0];
	declare netwrite Integer[] Net_Matchmaking_Format for Teams[0];
	Net_Matchmaking_FormatUpdate = Now;
	Net_Matchmaking_Format = G_Matchmaking_Format;
	
	Layers::Update("StartingMatch", Private_MM_GetMLStartingMatch());
}

// ---------------------------------- //
/** Initialize the match server for matchmaking
 *
 *	@param	_Format		The  match format
 */
Void MM_Init(Integer[] _Format) {
	MM_SetFormat(_Format);
	UseForcedClans = True;
}